"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.createSurfClient = void 0;
const createViewPayload_js_1 = require("./createViewPayload.js");
const createEntryPayload_js_1 = require("./createEntryPayload.js");
const bcs_js_1 = require("../utils/bcs.js");
function createSurfClient(aptosClient) {
    return new Client(aptosClient);
}
exports.createSurfClient = createSurfClient;
class Client {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "initiaClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if ('bank' in client && 'evm' in client) {
            this.initiaClient = client;
        }
        else {
            this.client = client;
        }
    }
    async view(args) {
        if (this.client) {
            return await this.client.view(args);
        }
        else if (this.initiaClient) {
            const functionParts = args.payload.function.split('::');
            if (functionParts.length !== 3) {
                throw new Error(`Invalid function format: ${args.payload.function}`);
            }
            if (!args.payload.functionArguments || !args.payload.typeArguments) {
                throw new Error('No function arguments or type arguments provided');
            }
            if (!args.payload.abi) {
                throw new Error('No ABI provided');
            }
            const [moduleAddress, moduleName, functionName] = functionParts;
            if (!moduleAddress || !moduleName || !functionName) {
                throw new Error('Invalid function format');
            }
            const bcsArgs = [];
            for (let i = 0; i < args.payload.functionArguments.length; i++) {
                const arg = args.payload.functionArguments[i];
                const paramType = args.payload.abi.parameters[i];
                if (!paramType) {
                    throw new Error('payload and abi mismatch');
                }
                const typeStr = paramType.toString();
                bcsArgs.push((0, bcs_js_1.bcsEncoding)(arg, typeStr));
            }
            const result = await this.initiaClient.move.viewFunction(moduleAddress, moduleName, functionName, args.payload.typeArguments.map((tag) => tag.toString()), bcsArgs);
            return args.payload.abi.returnTypes.length === 1
                ? [result]
                : result;
        }
        else {
            throw new Error('No client available');
        }
    }
    async submitTransaction(args) {
        if (this.client) {
            const transaction = await this.client.transaction.build.simple({
                sender: args.signer.accountAddress.toString(),
                data: {
                    function: args.payload.function,
                    typeArguments: args.payload.typeArguments,
                    functionArguments: args.payload.functionArguments,
                },
            });
            const transactionRes = await this.client.transaction.signAndSubmitTransaction({
                signer: args.signer,
                transaction,
            });
            return await this.client.waitForTransaction({
                transactionHash: transactionRes.hash,
                options: args.options ?? {},
            });
        }
        else {
            throw new Error('Not implemented');
        }
    }
    async simulateTransaction(args) {
        if (this.client) {
            const transaction = await this.client.transaction.build.simple({
                sender: args.sender,
                data: {
                    function: args.payload.function,
                    typeArguments: args.payload.typeArguments,
                    functionArguments: args.payload.functionArguments,
                },
            });
            return (await this.client.transaction.simulate.simple({
                signerPublicKey: args.publicKey,
                transaction,
            }))[0];
        }
        else {
            throw new Error('Not implemented');
        }
    }
    async fetchABI(address, moduleName) {
        if (this.client) {
            return (await this.client.getAccountModule({
                accountAddress: address,
                moduleName: moduleName,
            })).abi;
        }
        else {
            throw new Error('Not implemented');
        }
    }
    useABI(abi, address) {
        return {
            view: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = (0, createViewPayload_js_1.createViewPayload)(abi, {
                            address: (address ?? abi.address),
                            function: functionName,
                            typeArguments: args[0].typeArguments,
                            functionArguments: args[0].functionArguments,
                        });
                        return this.view({
                            payload,
                            options: {
                                ledgerVersion: args[0].ledgerVersion,
                            },
                        });
                    };
                },
            }),
            entry: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = (0, createEntryPayload_js_1.createEntryPayload)(abi, {
                            address: (address ?? abi.address),
                            function: functionName,
                            typeArguments: args[0].typeArguments,
                            functionArguments: args[0].functionArguments,
                        });
                        const account = args[0].account;
                        return args[0].isSimulation
                            ? this.simulateTransaction({
                                publicKey: account.publicKey,
                                sender: account.accountAddress.toString(),
                                payload,
                            })
                            : this.submitTransaction({
                                signer: args[0].account,
                                payload,
                            });
                    };
                },
            }),
            resource: new Proxy({}, {
                get: (_, prop) => {
                    let structName = prop.toString();
                    return (...args) => {
                        if (args[0].typeArguments.length !== 0) {
                            structName += `<${args[0].typeArguments.join(',')}>`;
                        }
                        const account = args[0].account;
                        if (this.client) {
                            return this.client.getAccountResource({
                                accountAddress: account,
                                resourceType: `${address ?? abi.address}::${abi.name}::${structName}`,
                                options: {
                                    ledgerVersion: args[0].ledgerVersion,
                                },
                            });
                        }
                        else if (this.initiaClient) {
                            return this.initiaClient.move
                                .resource(account.toString(), `${address ?? abi.address}::${abi.name}::${structName}`, {})
                                .then((res) => res.data);
                        }
                        else {
                            throw new Error('No client available');
                        }
                    };
                },
            }),
        };
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map