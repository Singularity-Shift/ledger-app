"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.27.1
// source: opinit/opchild/v1/types.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DenomPair = exports.CoinsWrapper = exports.BridgeInfo = exports.ValidatorUpdates = exports.Validator = exports.Params = exports.ResponseResultType = exports.protobufPackage = void 0;
exports.responseResultTypeFromJSON = responseResultTypeFromJSON;
exports.responseResultTypeToJSON = responseResultTypeToJSON;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const any_1 = require("../../../google/protobuf/any");
const types_1 = require("../../../tendermint/abci/types");
const types_2 = require("../../ophost/v1/types");
exports.protobufPackage = "opinit.opchild.v1";
/** ResponseResultType defines the possible outcomes of the execution of a message */
var ResponseResultType;
(function (ResponseResultType) {
    /** RESPONSE_RESULT_TYPE_UNSPECIFIED - Default zero value enumeration */
    ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED";
    /** RESPONSE_RESULT_TYPE_NOOP - The message did not execute msg operation (because, for example, deposit had already been finalized) */
    ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_NOOP"] = 1] = "RESPONSE_RESULT_TYPE_NOOP";
    /** RESPONSE_RESULT_TYPE_SUCCESS - The message was executed successfully */
    ResponseResultType[ResponseResultType["RESPONSE_RESULT_TYPE_SUCCESS"] = 2] = "RESPONSE_RESULT_TYPE_SUCCESS";
    ResponseResultType[ResponseResultType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseResultType || (exports.ResponseResultType = ResponseResultType = {}));
function responseResultTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
            return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_TYPE_NOOP":
            return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;
        case 2:
        case "RESPONSE_RESULT_TYPE_SUCCESS":
            return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseResultType.UNRECOGNIZED;
    }
}
function responseResultTypeToJSON(object) {
    switch (object) {
        case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:
            return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:
            return "RESPONSE_RESULT_TYPE_NOOP";
        case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:
            return "RESPONSE_RESULT_TYPE_SUCCESS";
        case ResponseResultType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseParams() {
    return {
        maxValidators: 0,
        historicalEntries: 0,
        minGasPrices: [],
        bridgeExecutors: [],
        admin: "",
        feeWhitelist: [],
        hookMaxGas: 0n,
    };
}
exports.Params = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.maxValidators !== 0) {
            writer.uint32(8).uint32(message.maxValidators);
        }
        if (message.historicalEntries !== 0) {
            writer.uint32(16).uint32(message.historicalEntries);
        }
        for (const v of message.minGasPrices) {
            coin_1.DecCoin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.bridgeExecutors) {
            writer.uint32(34).string(v);
        }
        if (message.admin !== "") {
            writer.uint32(42).string(message.admin);
        }
        for (const v of message.feeWhitelist) {
            writer.uint32(50).string(v);
        }
        if (message.hookMaxGas !== 0n) {
            if (BigInt.asUintN(64, message.hookMaxGas) !== message.hookMaxGas) {
                throw new gt.Error("value provided for field message.hookMaxGas of type uint64 too large");
            }
            writer.uint32(56).uint64(message.hookMaxGas.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.maxValidators = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.historicalEntries = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.minGasPrices.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.bridgeExecutors.push(reader.string());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.admin = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.feeWhitelist.push(reader.string());
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.hookMaxGas = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxValidators: isSet(object.maxValidators) ? gt.Number(object.maxValidators) : 0,
            historicalEntries: isSet(object.historicalEntries) ? gt.Number(object.historicalEntries) : 0,
            minGasPrices: gt.Array.isArray(object?.minGasPrices)
                ? object.minGasPrices.map((e) => coin_1.DecCoin.fromJSON(e))
                : [],
            bridgeExecutors: gt.Array.isArray(object?.bridgeExecutors)
                ? object.bridgeExecutors.map((e) => gt.String(e))
                : [],
            admin: isSet(object.admin) ? gt.String(object.admin) : "",
            feeWhitelist: gt.Array.isArray(object?.feeWhitelist)
                ? object.feeWhitelist.map((e) => gt.String(e))
                : [],
            hookMaxGas: isSet(object.hookMaxGas) ? BigInt(object.hookMaxGas) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maxValidators !== 0) {
            obj.maxValidators = Math.round(message.maxValidators);
        }
        if (message.historicalEntries !== 0) {
            obj.historicalEntries = Math.round(message.historicalEntries);
        }
        if (message.minGasPrices?.length) {
            obj.minGasPrices = message.minGasPrices.map((e) => coin_1.DecCoin.toJSON(e));
        }
        if (message.bridgeExecutors?.length) {
            obj.bridgeExecutors = message.bridgeExecutors;
        }
        if (message.admin !== "") {
            obj.admin = message.admin;
        }
        if (message.feeWhitelist?.length) {
            obj.feeWhitelist = message.feeWhitelist;
        }
        if (message.hookMaxGas !== 0n) {
            obj.hookMaxGas = message.hookMaxGas.toString();
        }
        return obj;
    },
    create(base) {
        return exports.Params.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams();
        message.maxValidators = object.maxValidators ?? 0;
        message.historicalEntries = object.historicalEntries ?? 0;
        message.minGasPrices = object.minGasPrices?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        message.bridgeExecutors = object.bridgeExecutors?.map((e) => e) || [];
        message.admin = object.admin ?? "";
        message.feeWhitelist = object.feeWhitelist?.map((e) => e) || [];
        message.hookMaxGas = object.hookMaxGas ?? 0n;
        return message;
    },
};
function createBaseValidator() {
    return { moniker: "", operatorAddress: "", consensusPubkey: undefined, consPower: 0n };
}
exports.Validator = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.moniker !== "") {
            writer.uint32(10).string(message.moniker);
        }
        if (message.operatorAddress !== "") {
            writer.uint32(18).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== undefined) {
            any_1.Any.encode(message.consensusPubkey, writer.uint32(26).fork()).ldelim();
        }
        if (message.consPower !== 0n) {
            if (BigInt.asIntN(64, message.consPower) !== message.consPower) {
                throw new gt.Error("value provided for field message.consPower of type int64 too large");
            }
            writer.uint32(32).int64(message.consPower.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.moniker = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.operatorAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.consPower = longToBigint(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            moniker: isSet(object.moniker) ? gt.String(object.moniker) : "",
            operatorAddress: isSet(object.operatorAddress) ? gt.String(object.operatorAddress) : "",
            consensusPubkey: isSet(object.consensusPubkey) ? any_1.Any.fromJSON(object.consensusPubkey) : undefined,
            consPower: isSet(object.consPower) ? BigInt(object.consPower) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.moniker !== "") {
            obj.moniker = message.moniker;
        }
        if (message.operatorAddress !== "") {
            obj.operatorAddress = message.operatorAddress;
        }
        if (message.consensusPubkey !== undefined) {
            obj.consensusPubkey = any_1.Any.toJSON(message.consensusPubkey);
        }
        if (message.consPower !== 0n) {
            obj.consPower = message.consPower.toString();
        }
        return obj;
    },
    create(base) {
        return exports.Validator.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidator();
        message.moniker = object.moniker ?? "";
        message.operatorAddress = object.operatorAddress ?? "";
        message.consensusPubkey =
            object.consensusPubkey !== undefined && object.consensusPubkey !== null
                ? any_1.Any.fromPartial(object.consensusPubkey)
                : undefined;
        message.consPower = object.consPower ?? 0n;
        return message;
    },
};
function createBaseValidatorUpdates() {
    return { updates: [] };
}
exports.ValidatorUpdates = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.updates) {
            types_1.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdates();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.updates.push(types_1.ValidatorUpdate.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            updates: gt.Array.isArray(object?.updates)
                ? object.updates.map((e) => types_1.ValidatorUpdate.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.updates?.length) {
            obj.updates = message.updates.map((e) => types_1.ValidatorUpdate.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ValidatorUpdates.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorUpdates();
        message.updates = object.updates?.map((e) => types_1.ValidatorUpdate.fromPartial(e)) || [];
        return message;
    },
};
function createBaseBridgeInfo() {
    return { bridgeId: 0n, bridgeAddr: "", l1ChainId: "", l1ClientId: "", bridgeConfig: undefined };
}
exports.BridgeInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.bridgeAddr !== "") {
            writer.uint32(18).string(message.bridgeAddr);
        }
        if (message.l1ChainId !== "") {
            writer.uint32(26).string(message.l1ChainId);
        }
        if (message.l1ClientId !== "") {
            writer.uint32(34).string(message.l1ClientId);
        }
        if (message.bridgeConfig !== undefined) {
            types_2.BridgeConfig.encode(message.bridgeConfig, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBridgeInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bridgeAddr = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.l1ChainId = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.l1ClientId = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.bridgeConfig = types_2.BridgeConfig.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            bridgeAddr: isSet(object.bridgeAddr) ? gt.String(object.bridgeAddr) : "",
            l1ChainId: isSet(object.l1ChainId) ? gt.String(object.l1ChainId) : "",
            l1ClientId: isSet(object.l1ClientId) ? gt.String(object.l1ClientId) : "",
            bridgeConfig: isSet(object.bridgeConfig) ? types_2.BridgeConfig.fromJSON(object.bridgeConfig) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.bridgeAddr !== "") {
            obj.bridgeAddr = message.bridgeAddr;
        }
        if (message.l1ChainId !== "") {
            obj.l1ChainId = message.l1ChainId;
        }
        if (message.l1ClientId !== "") {
            obj.l1ClientId = message.l1ClientId;
        }
        if (message.bridgeConfig !== undefined) {
            obj.bridgeConfig = types_2.BridgeConfig.toJSON(message.bridgeConfig);
        }
        return obj;
    },
    create(base) {
        return exports.BridgeInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBridgeInfo();
        message.bridgeId = object.bridgeId ?? 0n;
        message.bridgeAddr = object.bridgeAddr ?? "";
        message.l1ChainId = object.l1ChainId ?? "";
        message.l1ClientId = object.l1ClientId ?? "";
        message.bridgeConfig =
            object.bridgeConfig !== undefined && object.bridgeConfig !== null
                ? types_2.BridgeConfig.fromPartial(object.bridgeConfig)
                : undefined;
        return message;
    },
};
function createBaseCoinsWrapper() {
    return { coins: [] };
}
exports.CoinsWrapper = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.coins) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoinsWrapper();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { coins: gt.Array.isArray(object?.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.coins?.length) {
            obj.coins = message.coins.map((e) => coin_1.Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.CoinsWrapper.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoinsWrapper();
        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDenomPair() {
    return { denom: "", baseDenom: "" };
}
exports.DenomPair = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.baseDenom !== "") {
            writer.uint32(18).string(message.baseDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDenomPair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.baseDenom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? gt.String(object.denom) : "",
            baseDenom: isSet(object.baseDenom) ? gt.String(object.baseDenom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.baseDenom !== "") {
            obj.baseDenom = message.baseDenom;
        }
        return obj;
    },
    create(base) {
        return exports.DenomPair.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDenomPair();
        message.denom = object.denom ?? "";
        message.baseDenom = object.baseDenom ?? "";
        return message;
    },
};
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToBigint(long) {
    return BigInt(long.toString());
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=types.js.map