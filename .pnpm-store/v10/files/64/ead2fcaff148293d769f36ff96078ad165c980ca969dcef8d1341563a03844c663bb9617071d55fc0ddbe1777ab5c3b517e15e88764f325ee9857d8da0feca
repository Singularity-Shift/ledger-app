"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bcsEncoding = void 0;
const initia_js_1 = require("@initia/initia.js");
function bcsEncoding(arg, typeStr, target = 'base64') {
    const serializer = target === 'base64' ? 'toBase64' : 'toBytes';
    if (typeStr === 'address' || typeStr.startsWith('0x1::object::Object')) {
        return initia_js_1.bcs
            .address()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'bool') {
        return initia_js_1.bcs
            .bool()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u8') {
        return initia_js_1.bcs
            .u8()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u16') {
        return initia_js_1.bcs
            .u16()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u32') {
        return initia_js_1.bcs
            .u32()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u64') {
        return initia_js_1.bcs
            .u64()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u128') {
        return initia_js_1.bcs
            .u128()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u256') {
        return initia_js_1.bcs
            .u256()
            .serialize(arg)[serializer]();
    }
    else if (typeStr.startsWith('vector<u8>')) {
        return initia_js_1.bcs
            .vector(initia_js_1.bcs.u8())
            .serialize(arg)[serializer]();
    }
    else if (typeStr.startsWith('vector<')) {
        const innerTypeMatch = typeStr.match(/vector<([^>]+)>/);
        if (!innerTypeMatch) {
            throw new Error(`Unsupported vector type: ${typeStr}`);
        }
        const innerType = innerTypeMatch[1];
        if (innerType === 'address') {
            return initia_js_1.bcs
                .vector(initia_js_1.bcs.address())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'bool') {
            return initia_js_1.bcs
                .vector(initia_js_1.bcs.bool())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u8') {
            return initia_js_1.bcs
                .vector(initia_js_1.bcs.u8())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u64') {
            return initia_js_1.bcs
                .vector(initia_js_1.bcs.u64())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u128') {
            return initia_js_1.bcs
                .vector(initia_js_1.bcs.u128())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u256') {
            return initia_js_1.bcs
                .vector(initia_js_1.bcs.u256())
                .serialize(arg)[serializer]();
        }
        else {
            throw new Error(`Unsupported vector inner type: ${innerType}`);
        }
    }
    else {
        throw new Error(`Unsupported type: ${typeStr}`);
    }
}
exports.bcsEncoding = bcsEncoding;
//# sourceMappingURL=bcs.js.map