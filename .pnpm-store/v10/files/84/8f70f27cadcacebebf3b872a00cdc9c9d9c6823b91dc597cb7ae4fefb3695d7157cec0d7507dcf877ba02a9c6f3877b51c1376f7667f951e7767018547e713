"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.1
// source: initia/distribution/v1/distribution.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelegationDelegatorReward = exports.DelegatorStartingInfo = exports.ValidatorSlashEvents = exports.ValidatorSlashEvent = exports.ValidatorOutstandingRewards = exports.ValidatorAccumulatedCommission = exports.ValidatorCurrentRewards = exports.ValidatorHistoricalRewards = exports.DecPool = exports.Pool = exports.RewardWeight = exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
exports.protobufPackage = "initia.distribution.v1";
function createBaseParams() {
    return { communityTax: "", withdrawAddrEnabled: false, rewardWeights: [] };
}
exports.Params = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.communityTax !== "") {
            writer.uint32(10).string(message.communityTax);
        }
        if (message.withdrawAddrEnabled !== false) {
            writer.uint32(16).bool(message.withdrawAddrEnabled);
        }
        for (const v of message.rewardWeights) {
            exports.RewardWeight.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.communityTax = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.withdrawAddrEnabled = reader.bool();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.rewardWeights.push(exports.RewardWeight.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            communityTax: isSet(object.communityTax) ? gt.String(object.communityTax) : "",
            withdrawAddrEnabled: isSet(object.withdrawAddrEnabled) ? gt.Boolean(object.withdrawAddrEnabled) : false,
            rewardWeights: gt.Array.isArray(object?.rewardWeights)
                ? object.rewardWeights.map((e) => exports.RewardWeight.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.communityTax !== "") {
            obj.communityTax = message.communityTax;
        }
        if (message.withdrawAddrEnabled !== false) {
            obj.withdrawAddrEnabled = message.withdrawAddrEnabled;
        }
        if (message.rewardWeights?.length) {
            obj.rewardWeights = message.rewardWeights.map((e) => exports.RewardWeight.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Params.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams();
        message.communityTax = object.communityTax ?? "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
        message.rewardWeights = object.rewardWeights?.map((e) => exports.RewardWeight.fromPartial(e)) || [];
        return message;
    },
};
function createBaseRewardWeight() {
    return { denom: "", weight: "" };
}
exports.RewardWeight = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.weight !== "") {
            writer.uint32(18).string(message.weight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRewardWeight();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.weight = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? gt.String(object.denom) : "",
            weight: isSet(object.weight) ? gt.String(object.weight) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.weight !== "") {
            obj.weight = message.weight;
        }
        return obj;
    },
    create(base) {
        return exports.RewardWeight.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRewardWeight();
        message.denom = object.denom ?? "";
        message.weight = object.weight ?? "";
        return message;
    },
};
function createBasePool() {
    return { denom: "", coins: [] };
}
exports.Pool = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        for (const v of message.coins) {
            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? gt.String(object.denom) : "",
            coins: gt.Array.isArray(object?.coins) ? object.coins.map((e) => coin_1.Coin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.coins?.length) {
            obj.coins = message.coins.map((e) => coin_1.Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Pool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePool();
        message.denom = object.denom ?? "";
        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDecPool() {
    return { denom: "", decCoins: [] };
}
exports.DecPool = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        for (const v of message.decCoins) {
            coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecPool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.decCoins.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet(object.denom) ? gt.String(object.denom) : "",
            decCoins: gt.Array.isArray(object?.decCoins)
                ? object.decCoins.map((e) => coin_1.DecCoin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.decCoins?.length) {
            obj.decCoins = message.decCoins.map((e) => coin_1.DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.DecPool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDecPool();
        message.denom = object.denom ?? "";
        message.decCoins = object.decCoins?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseValidatorHistoricalRewards() {
    return { cumulativeRewardRatios: [], referenceCount: 0 };
}
exports.ValidatorHistoricalRewards = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.cumulativeRewardRatios) {
            exports.DecPool.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
            writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cumulativeRewardRatios.push(exports.DecPool.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.referenceCount = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cumulativeRewardRatios: gt.Array.isArray(object?.cumulativeRewardRatios)
                ? object.cumulativeRewardRatios.map((e) => exports.DecPool.fromJSON(e))
                : [],
            referenceCount: isSet(object.referenceCount) ? gt.Number(object.referenceCount) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatios?.length) {
            obj.cumulativeRewardRatios = message.cumulativeRewardRatios.map((e) => exports.DecPool.toJSON(e));
        }
        if (message.referenceCount !== 0) {
            obj.referenceCount = Math.round(message.referenceCount);
        }
        return obj;
    },
    create(base) {
        return exports.ValidatorHistoricalRewards.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatios = object.cumulativeRewardRatios?.map((e) => exports.DecPool.fromPartial(e)) || [];
        message.referenceCount = object.referenceCount ?? 0;
        return message;
    },
};
function createBaseValidatorCurrentRewards() {
    return { rewards: [], period: 0n };
}
exports.ValidatorCurrentRewards = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
            exports.DecPool.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== 0n) {
            if (BigInt.asUintN(64, message.period) !== message.period) {
                throw new gt.Error("value provided for field message.period of type uint64 too large");
            }
            writer.uint32(16).uint64(message.period.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rewards.push(exports.DecPool.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.period = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rewards: gt.Array.isArray(object?.rewards) ? object.rewards.map((e) => exports.DecPool.fromJSON(e)) : [],
            period: isSet(object.period) ? BigInt(object.period) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rewards?.length) {
            obj.rewards = message.rewards.map((e) => exports.DecPool.toJSON(e));
        }
        if (message.period !== 0n) {
            obj.period = message.period.toString();
        }
        return obj;
    },
    create(base) {
        return exports.ValidatorCurrentRewards.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorCurrentRewards();
        message.rewards = object.rewards?.map((e) => exports.DecPool.fromPartial(e)) || [];
        message.period = object.period ?? 0n;
        return message;
    },
};
function createBaseValidatorAccumulatedCommission() {
    return { commissions: [] };
}
exports.ValidatorAccumulatedCommission = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.commissions) {
            exports.DecPool.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.commissions.push(exports.DecPool.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            commissions: gt.Array.isArray(object?.commissions)
                ? object.commissions.map((e) => exports.DecPool.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.commissions?.length) {
            obj.commissions = message.commissions.map((e) => exports.DecPool.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ValidatorAccumulatedCommission.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorAccumulatedCommission();
        message.commissions = object.commissions?.map((e) => exports.DecPool.fromPartial(e)) || [];
        return message;
    },
};
function createBaseValidatorOutstandingRewards() {
    return { rewards: [] };
}
exports.ValidatorOutstandingRewards = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rewards) {
            exports.DecPool.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rewards.push(exports.DecPool.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rewards: gt.Array.isArray(object?.rewards) ? object.rewards.map((e) => exports.DecPool.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rewards?.length) {
            obj.rewards = message.rewards.map((e) => exports.DecPool.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ValidatorOutstandingRewards.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorOutstandingRewards();
        message.rewards = object.rewards?.map((e) => exports.DecPool.fromPartial(e)) || [];
        return message;
    },
};
function createBaseValidatorSlashEvent() {
    return { validatorPeriod: 0n, fractions: [] };
}
exports.ValidatorSlashEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorPeriod !== 0n) {
            if (BigInt.asUintN(64, message.validatorPeriod) !== message.validatorPeriod) {
                throw new gt.Error("value provided for field message.validatorPeriod of type uint64 too large");
            }
            writer.uint32(8).uint64(message.validatorPeriod.toString());
        }
        for (const v of message.fractions) {
            coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.validatorPeriod = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fractions.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorPeriod: isSet(object.validatorPeriod) ? BigInt(object.validatorPeriod) : 0n,
            fractions: gt.Array.isArray(object?.fractions)
                ? object.fractions.map((e) => coin_1.DecCoin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorPeriod !== 0n) {
            obj.validatorPeriod = message.validatorPeriod.toString();
        }
        if (message.fractions?.length) {
            obj.fractions = message.fractions.map((e) => coin_1.DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ValidatorSlashEvent.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorSlashEvent();
        message.validatorPeriod = object.validatorPeriod ?? 0n;
        message.fractions = object.fractions?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseValidatorSlashEvents() {
    return { validatorSlashEvents: [] };
}
exports.ValidatorSlashEvents = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.validatorSlashEvents) {
            exports.ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorSlashEvents.push(exports.ValidatorSlashEvent.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorSlashEvents: gt.Array.isArray(object?.validatorSlashEvents)
                ? object.validatorSlashEvents.map((e) => exports.ValidatorSlashEvent.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents?.length) {
            obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => exports.ValidatorSlashEvent.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ValidatorSlashEvents.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents =
            object.validatorSlashEvents?.map((e) => exports.ValidatorSlashEvent.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDelegatorStartingInfo() {
    return { previousPeriod: 0n, stakes: [], height: 0n };
}
exports.DelegatorStartingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.previousPeriod !== 0n) {
            if (BigInt.asUintN(64, message.previousPeriod) !== message.previousPeriod) {
                throw new gt.Error("value provided for field message.previousPeriod of type uint64 too large");
            }
            writer.uint32(8).uint64(message.previousPeriod.toString());
        }
        for (const v of message.stakes) {
            coin_1.DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== 0n) {
            if (BigInt.asUintN(64, message.height) !== message.height) {
                throw new gt.Error("value provided for field message.height of type uint64 too large");
            }
            writer.uint32(24).uint64(message.height.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.previousPeriod = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.stakes.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.height = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            previousPeriod: isSet(object.previousPeriod) ? BigInt(object.previousPeriod) : 0n,
            stakes: gt.Array.isArray(object?.stakes) ? object.stakes.map((e) => coin_1.DecCoin.fromJSON(e)) : [],
            height: isSet(object.height) ? BigInt(object.height) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.previousPeriod !== 0n) {
            obj.previousPeriod = message.previousPeriod.toString();
        }
        if (message.stakes?.length) {
            obj.stakes = message.stakes.map((e) => coin_1.DecCoin.toJSON(e));
        }
        if (message.height !== 0n) {
            obj.height = message.height.toString();
        }
        return obj;
    },
    create(base) {
        return exports.DelegatorStartingInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDelegatorStartingInfo();
        message.previousPeriod = object.previousPeriod ?? 0n;
        message.stakes = object.stakes?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        message.height = object.height ?? 0n;
        return message;
    },
};
function createBaseDelegationDelegatorReward() {
    return { validatorAddress: "", reward: [] };
}
exports.DelegationDelegatorReward = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
            writer.uint32(10).string(message.validatorAddress);
        }
        for (const v of message.reward) {
            exports.DecPool.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.reward.push(exports.DecPool.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorAddress: isSet(object.validatorAddress) ? gt.String(object.validatorAddress) : "",
            reward: gt.Array.isArray(object?.reward) ? object.reward.map((e) => exports.DecPool.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.reward?.length) {
            obj.reward = message.reward.map((e) => exports.DecPool.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.DelegationDelegatorReward.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDelegationDelegatorReward();
        message.validatorAddress = object.validatorAddress ?? "";
        message.reward = object.reward?.map((e) => exports.DecPool.fromPartial(e)) || [];
        return message;
    },
};
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToBigint(long) {
    return BigInt(long.toString());
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=distribution.js.map