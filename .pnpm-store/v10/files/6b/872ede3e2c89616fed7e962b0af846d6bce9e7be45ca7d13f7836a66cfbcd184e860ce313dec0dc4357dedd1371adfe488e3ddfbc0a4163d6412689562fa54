"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetListSchema = void 0;
const zod_1 = require("zod");
exports.AssetListSchema = zod_1.z
    .object({
    $schema: zod_1.z
        .string()
        .regex(new RegExp("^(\\.\\./)+assetlist\\.schema\\.json$"))
        .optional(),
    chain_name: zod_1.z.string(),
    assets: zod_1.z.array(zod_1.z
        .object({
        description: zod_1.z
            .string()
            .describe("[OPTIONAL] A short description of the asset")
            .optional(),
        denom_units: zod_1.z.array(zod_1.z
            .object({
            denom: zod_1.z.string(),
            exponent: zod_1.z.number().int(),
            aliases: zod_1.z.array(zod_1.z.string()).optional(),
        })
            .strict()),
        type_asset: zod_1.z
            .enum(["sdk.coin", "cw20", "erc20", "ics20", "snip20", "snip25"])
            .describe("[OPTIONAL] The potential options for type of asset. By default, assumes sdk.coin")
            .default("sdk.coin"),
        address: zod_1.z
            .string()
            .describe("[OPTIONAL] The address of the asset. Only required for type_asset : cw20, snip20")
            .optional(),
        base: zod_1.z
            .string()
            .describe("The base unit of the asset. Must be in denom_units."),
        name: zod_1.z
            .string()
            .max(42)
            .describe("The project name of the asset. For example Bitcoin."),
        display: zod_1.z
            .string()
            .describe("The human friendly unit of the asset. Must be in denom_units."),
        symbol: zod_1.z
            .string()
            .describe("The symbol of an asset. For example BTC."),
        traces: zod_1.z
            .array(zod_1.z.union([
            zod_1.z
                .object({
                type: zod_1.z.literal("ibc"),
                counterparty: zod_1.z
                    .object({
                    chain_name: zod_1.z
                        .string()
                        .describe("The name of the counterparty chain. (must match exactly the chain name used in the Chain Registry)"),
                    base_denom: zod_1.z
                        .string()
                        .describe("The base unit of the asset on its source platform. E.g., when describing ATOM from Cosmos Hub, specify 'uatom', NOT 'atom' nor 'ATOM'; base units are unique per platform."),
                    channel_id: zod_1.z
                        .string()
                        .regex(new RegExp("^channel-\\d+$"))
                        .describe("The counterparty IBC transfer channel(, e.g., 'channel-1')."),
                })
                    .strict(),
                chain: zod_1.z
                    .object({
                    channel_id: zod_1.z
                        .string()
                        .regex(new RegExp("^channel-\\d+$"))
                        .describe("The chain's IBC transfer channel(, e.g., 'channel-1')."),
                    path: zod_1.z
                        .string()
                        .describe("The port/channel/denom input string that generates the 'ibc/...' denom."),
                })
                    .strict(),
            })
                .strict(),
            zod_1.z
                .object({
                type: zod_1.z.literal("ibc-cw20"),
                counterparty: zod_1.z
                    .object({
                    chain_name: zod_1.z
                        .string()
                        .describe("The name of the counterparty chain. (must match exactly the chain name used in the Chain Registry)"),
                    base_denom: zod_1.z
                        .string()
                        .describe("The base unit of the asset on its source platform. E.g., when describing ATOM from Cosmos Hub, specify 'uatom', NOT 'atom' nor 'ATOM'; base units are unique per platform."),
                    port: zod_1.z
                        .string()
                        .describe("The port used to transfer IBC assets; often 'transfer', but sometimes varies, e.g., for outgoing cw20 transfers."),
                    channel_id: zod_1.z
                        .string()
                        .regex(new RegExp("^channel-\\d+$"))
                        .describe("The counterparty IBC transfer channel(, e.g., 'channel-1')."),
                })
                    .strict(),
                chain: zod_1.z
                    .object({
                    port: zod_1.z
                        .string()
                        .describe("The port used to transfer IBC assets; often 'transfer', but sometimes varies, e.g., for outgoing cw20 transfers."),
                    channel_id: zod_1.z
                        .string()
                        .regex(new RegExp("^channel-\\d+$"))
                        .describe("The chain's IBC transfer channel(, e.g., 'channel-1')."),
                    path: zod_1.z
                        .string()
                        .describe("The port/channel/denom input string that generates the 'ibc/...' denom."),
                })
                    .strict(),
            })
                .strict(),
            zod_1.z
                .object({
                type: zod_1.z.enum([
                    "bridge",
                    "liquid-stake",
                    "synthetic",
                    "wrapped",
                    "additional-mintage",
                    "test-mintage",
                ]),
                counterparty: zod_1.z
                    .object({
                    chain_name: zod_1.z
                        .string()
                        .describe("The chain or platform from which the asset originates. E.g., 'cosmoshub', 'ethereum', 'forex', or 'nasdaq'"),
                    base_denom: zod_1.z.string(),
                    contract: zod_1.z
                        .string()
                        .describe("The contract address where the transition takes place, where applicable. E.g., The Ethereum contract that locks up the asset while it's minted on another chain.")
                        .optional(),
                })
                    .strict(),
                chain: zod_1.z
                    .object({
                    contract: zod_1.z
                        .string()
                        .describe("The contract address where the transition takes place, where applicable. E.g., The Ethereum contract that locks up the asset while it's minted on another chain."),
                })
                    .strict()
                    .optional(),
                provider: zod_1.z
                    .string()
                    .describe("The entity offering the service. E.g., 'Gravity Bridge' [Network] or 'Tether' [Company]."),
            })
                .strict(),
            zod_1.z
                .object({
                type: zod_1.z.literal("op"),
                counterparty: zod_1.z
                    .object({
                    chain_name: zod_1.z
                        .string()
                        .describe("The name of the counterparty chain. (must match exactly the chain name used in the Chain Registry)"),
                    base_denom: zod_1.z
                        .string()
                        .describe("The base unit of the asset on its source platform. E.g., when describing ATOM from Cosmos Hub, specify 'uatom', NOT 'atom' nor 'ATOM'; base units are unique per platform."),
                })
                    .strict(),
                chain: zod_1.z
                    .object({
                    bridge_id: zod_1.z
                        .string()
                        .describe("The identifier of the OPinit bridge used to transfer assets between L1 and L2."),
                })
                    .strict(),
            })
                .strict(),
        ]))
            .describe("The origin of the asset, starting with the index, and capturing all transitions in form and location.")
            .optional(),
        ibc: zod_1.z
            .object({
            source_channel: zod_1.z.string(),
            dst_channel: zod_1.z.string(),
            source_denom: zod_1.z.string(),
        })
            .strict()
            .describe("[OPTIONAL] IBC Channel between src and dst between chain")
            .optional(),
        logo_URIs: zod_1.z
            .object({
            png: zod_1.z
                .string()
                .regex(new RegExp("^https://.+\\.png$"))
                .optional(),
        })
            .strict()
            .optional(),
        images: zod_1.z
            .array(zod_1.z
            .object({
            image_sync: zod_1.z
                .object({
                chain_name: zod_1.z
                    .string()
                    .describe("The chain name or platform from which the object resides. E.g., 'cosmoshub', 'ethereum', 'forex', or 'nasdaq'"),
                base_denom: zod_1.z
                    .string()
                    .describe("The base denom of the asset from which the object originates. E.g., when describing ATOM from Cosmos Hub, specify 'uatom', NOT 'atom' nor 'ATOM'; base units are unique per platform.")
                    .optional(),
            })
                .strict()
                .describe("The (primary) key used to identify an object within the Chain Registry.")
                .optional(),
            png: zod_1.z
                .string()
                .regex(new RegExp("^https://.+\\.png$"))
                .optional(),
            theme: zod_1.z
                .object({
                primary_color_hex: zod_1.z
                    .string()
                    .regex(new RegExp("^#[0-9a-fA-F]{6}$"))
                    .optional(),
                circle: zod_1.z.boolean().optional(),
                dark_mode: zod_1.z.boolean().optional(),
            })
                .strict()
                .optional(),
        })
            .strict())
            .min(1)
            .optional(),
        coingecko_id: zod_1.z
            .string()
            .describe("[OPTIONAL] The coingecko id to fetch asset data from coingecko v3 api. See https://api.coingecko.com/api/v3/coins/list")
            .optional(),
        keywords: zod_1.z.array(zod_1.z.string()).optional(),
    })
        .strict()),
})
    .strict()
    .describe("Asset lists are a similar mechanism to allow frontends and other UIs to fetch metadata associated with Cosmos SDK denoms, especially for assets sent over IBC.");
//# sourceMappingURL=AssetList.js.map