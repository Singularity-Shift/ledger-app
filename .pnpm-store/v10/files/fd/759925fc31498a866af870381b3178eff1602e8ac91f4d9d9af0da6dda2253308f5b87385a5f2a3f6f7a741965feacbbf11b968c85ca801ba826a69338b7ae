"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainSchema = void 0;
const zod_1 = require("zod");
exports.ChainSchema = zod_1.z
    .object({
    $schema: zod_1.z
        .string()
        .regex(new RegExp("^(\\.\\./)+chain\\.schema\\.json$"))
        .optional(),
    chain_name: zod_1.z.string().regex(new RegExp("[a-z0-9]+")),
    chain_id: zod_1.z.string().regex(new RegExp("[a-z0-9]+")),
    evm_chain_id: zod_1.z.number().optional(),
    pre_fork_chain_name: zod_1.z.string().regex(new RegExp("[a-z0-9]+")).optional(),
    pretty_name: zod_1.z.string().optional(),
    website: zod_1.z.string().url().optional(),
    update_link: zod_1.z.string().url().optional(),
    status: zod_1.z.enum(["live", "upcoming", "killed"]).optional(),
    network_type: zod_1.z.enum(["mainnet", "testnet", "devnet"]),
    bech32_prefix: zod_1.z
        .literal("init")
        .describe("The default prefix for the human-readable part of addresses that identifies the coin type."),
    bech32_config: zod_1.z
        .object({
        bech32PrefixAccAddr: zod_1.z.string().describe("e.g., 'cosmos'").optional(),
        bech32PrefixAccPub: zod_1.z.string().describe("e.g., 'cosmospub'").optional(),
        bech32PrefixValAddr: zod_1.z
            .string()
            .describe("e.g., 'cosmosvaloper'")
            .optional(),
        bech32PrefixValPub: zod_1.z
            .string()
            .describe("e.g., 'cosmosvaloperpub'")
            .optional(),
        bech32PrefixConsAddr: zod_1.z
            .string()
            .describe("e.g., 'cosmosvalcons'")
            .optional(),
        bech32PrefixConsPub: zod_1.z
            .string()
            .describe("e.g., 'cosmosvalconspub'")
            .optional(),
    })
        .strict()
        .describe("Used to override the bech32_prefix for specific uses.")
        .optional(),
    daemon_name: zod_1.z.string().optional(),
    node_home: zod_1.z.string().optional(),
    key_algos: zod_1.z
        .array(zod_1.z.enum([
        "secp256k1",
        "initia_ethsecp256k1",
        "ed25519",
        "sr25519",
        "bn254",
    ]))
        .optional(),
    slip44: zod_1.z.number().optional(),
    alternative_slip44s: zod_1.z.array(zod_1.z.number()).optional(),
    fees: zod_1.z
        .object({
        fee_tokens: zod_1.z.array(zod_1.z
            .object({
            denom: zod_1.z
                .string()
                .regex(new RegExp("^[a-zA-Z][a-zA-Z0-9/:._-]{2,127}$")),
            fixed_min_gas_price: zod_1.z.number().optional(),
            low_gas_price: zod_1.z.number().optional(),
            average_gas_price: zod_1.z.number().optional(),
            high_gas_price: zod_1.z.number().optional(),
            gas_costs: zod_1.z
                .object({
                cosmos_send: zod_1.z.number().optional(),
                ibc_transfer: zod_1.z.number().optional(),
            })
                .strict()
                .optional(),
        })
            .strict()),
    })
        .strict(),
    staking: zod_1.z
        .object({
        staking_tokens: zod_1.z.array(zod_1.z
            .object({
            denom: zod_1.z
                .string()
                .regex(new RegExp("^[a-zA-Z][a-zA-Z0-9/:._-]{2,127}$")),
        })
            .strict()),
        lock_duration: zod_1.z
            .object({
            blocks: zod_1.z
                .number()
                .describe("The number of blocks for which the staked tokens are locked.")
                .optional(),
            time: zod_1.z
                .string()
                .describe("The approximate time for which the staked tokens are locked.")
                .optional(),
        })
            .strict()
            .optional(),
    })
        .strict()
        .optional(),
    codebase: zod_1.z
        .object({
        git_repo: zod_1.z.string().url().optional(),
        recommended_version: zod_1.z.string().optional(),
        go_version: zod_1.z
            .string()
            .regex(new RegExp("^[0-9]+\\.[0-9]+(\\.[0-9]+)?$"))
            .describe("Minimum accepted go version to build the binary.")
            .optional(),
        compatible_versions: zod_1.z.array(zod_1.z.string()).optional(),
        binaries: zod_1.z
            .object({
            "linux/amd64": zod_1.z.string().url().optional(),
            "linux/arm64": zod_1.z.string().url().optional(),
            "darwin/amd64": zod_1.z.string().url().optional(),
            "darwin/arm64": zod_1.z.string().url().optional(),
            "windows/amd64": zod_1.z.string().url().optional(),
            "windows/arm64": zod_1.z.string().url().optional(),
        })
            .strict()
            .optional(),
        cosmos_sdk_version: zod_1.z.string().optional(),
        consensus: zod_1.z
            .object({
            type: zod_1.z.enum(["tendermint", "cometbft", "sei-tendermint"]),
            version: zod_1.z.string().optional(),
        })
            .strict()
            .optional(),
        cosmwasm_version: zod_1.z.string().optional(),
        cosmwasm_enabled: zod_1.z.boolean().optional(),
        cosmwasm_path: zod_1.z
            .string()
            .regex(new RegExp("^\\$HOME.*$"))
            .describe("Relative path to the cosmwasm directory. ex. $HOME/.initia/data/wasm")
            .optional(),
        ibc_go_version: zod_1.z.string().optional(),
        ics_enabled: zod_1.z
            .array(zod_1.z
            .enum(["ics20-1", "ics27-1", "mauth"])
            .describe("IBC app or ICS standard."))
            .describe("List of IBC apps (usually corresponding to a ICS standard) which have been enabled on the network.")
            .optional(),
        genesis: zod_1.z
            .object({
            name: zod_1.z.string().optional(),
            genesis_url: zod_1.z.string().url(),
            ics_ccv_url: zod_1.z.string().url().optional(),
        })
            .strict()
            .optional(),
        versions: zod_1.z
            .array(zod_1.z
            .object({
            name: zod_1.z.string().describe("Official Upgrade Name"),
            tag: zod_1.z.string().describe("Git Upgrade Tag").optional(),
            height: zod_1.z.number().describe("Block Height").optional(),
            proposal: zod_1.z
                .number()
                .describe("Proposal that will officially signal community acceptance of the upgrade.")
                .optional(),
            previous_version_name: zod_1.z
                .string()
                .describe("[Optional] Name of the previous version")
                .optional(),
            next_version_name: zod_1.z
                .string()
                .describe("[Optional] Name of the following version")
                .optional(),
            recommended_version: zod_1.z.string().optional(),
            go_version: zod_1.z
                .string()
                .regex(new RegExp("^[0-9]+\\.[0-9]+(\\.[0-9]+)?$"))
                .describe("Minimum accepted go version to build the binary.")
                .optional(),
            compatible_versions: zod_1.z.array(zod_1.z.string()).optional(),
            cosmos_sdk_version: zod_1.z.string().optional(),
            consensus: zod_1.z
                .object({
                type: zod_1.z.enum(["tendermint", "cometbft", "sei-tendermint"]),
                version: zod_1.z.string().optional(),
            })
                .strict()
                .optional(),
            cosmwasm_version: zod_1.z.string().optional(),
            cosmwasm_enabled: zod_1.z.boolean().optional(),
            cosmwasm_path: zod_1.z
                .string()
                .regex(new RegExp("^\\$HOME.*$"))
                .describe("Relative path to the cosmwasm directory. ex. $HOME/.initia/data/wasm")
                .optional(),
            ibc_go_version: zod_1.z.string().optional(),
            ics_enabled: zod_1.z
                .array(zod_1.z
                .enum(["ics20-1", "ics27-1", "mauth"])
                .describe("IBC app or ICS standard."))
                .describe("List of IBC apps (usually corresponding to a ICS standard) which have been enabled on the network.")
                .optional(),
            binaries: zod_1.z
                .object({
                "linux/amd64": zod_1.z.string().url().optional(),
                "linux/arm64": zod_1.z.string().url().optional(),
                "darwin/amd64": zod_1.z.string().url().optional(),
                "darwin/arm64": zod_1.z.string().url().optional(),
                "windows/amd64": zod_1.z.string().url().optional(),
                "windows/arm64": zod_1.z.string().url().optional(),
            })
                .strict()
                .optional(),
        })
            .strict())
            .optional(),
    })
        .strict()
        .optional(),
    images: zod_1.z
        .array(zod_1.z
        .object({
        image_sync: zod_1.z
            .object({
            chain_name: zod_1.z
                .string()
                .describe("The chain name or platform from which the object resides. E.g., 'cosmoshub', 'ethereum', 'forex', or 'nasdaq'"),
            base_denom: zod_1.z
                .string()
                .describe("The base denom of the asset from which the object originates. E.g., when describing ATOM from Cosmos Hub, specify 'uatom', NOT 'atom' nor 'ATOM'; base units are unique per platform.")
                .optional(),
        })
            .strict()
            .describe("The (primary) key used to identify an object within the Chain Registry.")
            .optional(),
        png: zod_1.z.string().regex(new RegExp("^https://.+\\.png$")).optional(),
        theme: zod_1.z
            .object({
            primary_color_hex: zod_1.z
                .string()
                .regex(new RegExp("^#[0-9a-fA-F]{6}$"))
                .optional(),
            circle: zod_1.z.boolean().optional(),
            dark_mode: zod_1.z.boolean().optional(),
        })
            .strict()
            .optional(),
        layout: zod_1.z
            .enum(["logo", "logomark", "logotype"])
            .describe("logomark == icon only; logotype == text only; logo == icon + text.")
            .optional(),
        text_position: zod_1.z
            .enum(["top", "bottom", "left", "right", "integrated"])
            .describe("Indicates in which position the text is placed, in case the layout is 'icon' type, it's required only in this case.")
            .optional(),
    })
        .strict()
        .and(zod_1.z.any()))
        .optional(),
    logo_URIs: zod_1.z
        .object({
        png: zod_1.z.string().regex(new RegExp("^https://.+\\.png$")).optional(),
    })
        .strict()
        .optional(),
    description: zod_1.z.string().max(3000).optional(),
    peers: zod_1.z
        .object({
        seeds: zod_1.z
            .array(zod_1.z
            .object({
            id: zod_1.z.string(),
            address: zod_1.z.string(),
            provider: zod_1.z.string().optional(),
        })
            .strict())
            .optional(),
        persistent_peers: zod_1.z
            .array(zod_1.z
            .object({
            id: zod_1.z.string(),
            address: zod_1.z.string(),
            provider: zod_1.z.string().optional(),
        })
            .strict())
            .optional(),
    })
        .strict()
        .optional(),
    apis: zod_1.z
        .object({
        rpc: zod_1.z.array(zod_1.z
            .object({
            address: zod_1.z.string().url().regex(new RegExp("^https://.")),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict()),
        rest: zod_1.z.array(zod_1.z
            .object({
            address: zod_1.z.string().url().regex(new RegExp("^https://.")),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict()),
        api: zod_1.z
            .array(zod_1.z
            .object({
            address: zod_1.z.string().url().regex(new RegExp("^https://.")),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict())
            .optional(),
        grpc: zod_1.z
            .array(zod_1.z
            .object({
            address: zod_1.z.string().url(),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict())
            .optional(),
        wss: zod_1.z
            .array(zod_1.z
            .object({
            address: zod_1.z.string().url(),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict())
            .optional(),
        "grpc-web": zod_1.z
            .array(zod_1.z
            .object({
            address: zod_1.z.string().url(),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict())
            .optional(),
        "json-rpc": zod_1.z
            .array(zod_1.z
            .object({
            address: zod_1.z.string().url().regex(new RegExp("^https://.")),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict())
            .describe("Evm json rpc uri")
            .optional(),
        "json-rpc-websocket": zod_1.z
            .array(zod_1.z
            .object({
            address: zod_1.z.string().url(),
            provider: zod_1.z.string().optional(),
            archive: zod_1.z.boolean().default(false),
            authorizedUser: zod_1.z.string().optional(),
            indexForSkip: zod_1.z.number().optional(),
        })
            .strict())
            .describe("Evm json rpc websocket uri")
            .optional(),
    })
        .strict(),
    explorers: zod_1.z
        .array(zod_1.z
        .object({
        kind: zod_1.z.string().optional(),
        url: zod_1.z.string().url().optional(),
        tx_page: zod_1.z.string().optional(),
        account_page: zod_1.z.string().optional(),
    })
        .strict())
        .optional(),
    faucets: zod_1.z
        .array(zod_1.z
        .object({
        kind: zod_1.z.string().optional(),
        url: zod_1.z.string().url().optional(),
    })
        .strict())
        .optional(),
    keywords: zod_1.z.array(zod_1.z.string()).optional(),
    extra_codecs: zod_1.z.array(zod_1.z.enum(["ethermint", "injective"])).optional(),
    metadata: zod_1.z
        .object({
        is_l1: zod_1.z
            .boolean()
            .describe("[Optional] Indicates if the chain is a layer 1 chain.")
            .optional(),
        op_bridge_id: zod_1.z
            .string()
            .describe("[Optional] The identifier of the OPinit bridge used to transfer assets between L1 and L2.")
            .optional(),
        executor_uri: zod_1.z
            .string()
            .url()
            .describe("[Optional] The OPInit executor api endpoint")
            .optional(),
        op_denoms: zod_1.z
            .array(zod_1.z.string())
            .describe("[Optional] The list of denoms that are supported by the OPinit bridge.")
            .optional(),
        free_tx_threshold: zod_1.z
            .array(zod_1.z
            .object({
            denom: zod_1.z
                .string()
                .regex(new RegExp("^[a-zA-Z][a-zA-Z0-9/:._-]{2,127}$")),
            amount: zod_1.z.string().regex(new RegExp("^[0-9]+$")),
        })
            .strict())
            .describe("[Optional] A list specifying coin amounts by denomination that exempt users from transaction fees when their balance meets or exceeds these amounts.")
            .optional(),
        ibc_channels: zod_1.z
            .array(zod_1.z
            .object({
            chain_id: zod_1.z.string(),
            port_id: zod_1.z.string(),
            channel_id: zod_1.z.string(),
            version: zod_1.z.string(),
        })
            .strict())
            .describe("[Optional] The list of IBC channels that are supported by the chain.")
            .optional(),
        assetlist: zod_1.z
            .string()
            .describe("URL pointing to the asset list, which provides metadata associated with Cosmos denoms.")
            .optional(),
        minitia: zod_1.z
            .object({
            type: zod_1.z.enum(["minimove", "miniwasm", "minievm", "custom"]),
            version: zod_1.z.string().describe("Version of minitia"),
        })
            .describe("[Optional] The type of minitia and the version of it ")
            .optional(),
    })
        .catchall(zod_1.z.any())
        .optional(),
})
    .strict()
    .describe("Cosmos Chain.json is a metadata file that contains information about a cosmos sdk based chain.");
//# sourceMappingURL=Chain.js.map