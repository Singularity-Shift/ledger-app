"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.1
// source: initia/move/v1/types.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecuteAuthorizationItem = exports.DexPair = exports.UpgradePolicyProto = exports.TableEntry = exports.TableInfo = exports.Resource = exports.Checksum = exports.Module = exports.RawParams = exports.Params = exports.upgradePolicyToJSON = exports.upgradePolicyFromJSON = exports.UpgradePolicy = exports.protobufPackage = void 0;
/* eslint-disable */
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "initia.move.v1";
/** UpgradePolicy is the policy for upgrading a move module. */
var UpgradePolicy;
(function (UpgradePolicy) {
    /** UNSPECIFIED - UNSPECIFIED: a placeholder for an unspecified upgrade policy. */
    UpgradePolicy[UpgradePolicy["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * COMPATIBLE - COMPATIBLE: Whether a compatibility check should be performed for upgrades. The check only passes if
     * a new module has (a) the same public functions (b) for existing resources, no layout change.
     */
    UpgradePolicy[UpgradePolicy["COMPATIBLE"] = 1] = "COMPATIBLE";
    /** IMMUTABLE - IMMUTABLE: Whether the modules in the package are immutable and cannot be upgraded. */
    UpgradePolicy[UpgradePolicy["IMMUTABLE"] = 2] = "IMMUTABLE";
    UpgradePolicy[UpgradePolicy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(UpgradePolicy || (exports.UpgradePolicy = UpgradePolicy = {}));
function upgradePolicyFromJSON(object) {
    switch (object) {
        case 0:
        case "UNSPECIFIED":
            return UpgradePolicy.UNSPECIFIED;
        case 1:
        case "COMPATIBLE":
            return UpgradePolicy.COMPATIBLE;
        case 2:
        case "IMMUTABLE":
            return UpgradePolicy.IMMUTABLE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return UpgradePolicy.UNRECOGNIZED;
    }
}
exports.upgradePolicyFromJSON = upgradePolicyFromJSON;
function upgradePolicyToJSON(object) {
    switch (object) {
        case UpgradePolicy.UNSPECIFIED:
            return "UNSPECIFIED";
        case UpgradePolicy.COMPATIBLE:
            return "COMPATIBLE";
        case UpgradePolicy.IMMUTABLE:
            return "IMMUTABLE";
        case UpgradePolicy.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.upgradePolicyToJSON = upgradePolicyToJSON;
function createBaseParams() {
    return {
        baseDenom: "",
        baseMinGasPrice: "",
        contractSharedRevenueRatio: "",
        scriptEnabled: false,
        allowedPublishers: [],
    };
}
exports.Params = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseDenom !== "") {
            writer.uint32(10).string(message.baseDenom);
        }
        if (message.baseMinGasPrice !== "") {
            writer.uint32(18).string(message.baseMinGasPrice);
        }
        if (message.contractSharedRevenueRatio !== "") {
            writer.uint32(26).string(message.contractSharedRevenueRatio);
        }
        if (message.scriptEnabled !== false) {
            writer.uint32(32).bool(message.scriptEnabled);
        }
        for (const v of message.allowedPublishers) {
            writer.uint32(42).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.baseDenom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.baseMinGasPrice = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.contractSharedRevenueRatio = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.scriptEnabled = reader.bool();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.allowedPublishers.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            baseDenom: isSet(object.baseDenom) ? gt.String(object.baseDenom) : "",
            baseMinGasPrice: isSet(object.baseMinGasPrice) ? gt.String(object.baseMinGasPrice) : "",
            contractSharedRevenueRatio: isSet(object.contractSharedRevenueRatio)
                ? gt.String(object.contractSharedRevenueRatio)
                : "",
            scriptEnabled: isSet(object.scriptEnabled) ? gt.Boolean(object.scriptEnabled) : false,
            allowedPublishers: gt.Array.isArray(object?.allowedPublishers)
                ? object.allowedPublishers.map((e) => gt.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.baseDenom !== "") {
            obj.baseDenom = message.baseDenom;
        }
        if (message.baseMinGasPrice !== "") {
            obj.baseMinGasPrice = message.baseMinGasPrice;
        }
        if (message.contractSharedRevenueRatio !== "") {
            obj.contractSharedRevenueRatio = message.contractSharedRevenueRatio;
        }
        if (message.scriptEnabled !== false) {
            obj.scriptEnabled = message.scriptEnabled;
        }
        if (message.allowedPublishers?.length) {
            obj.allowedPublishers = message.allowedPublishers;
        }
        return obj;
    },
    create(base) {
        return exports.Params.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams();
        message.baseDenom = object.baseDenom ?? "";
        message.baseMinGasPrice = object.baseMinGasPrice ?? "";
        message.contractSharedRevenueRatio = object.contractSharedRevenueRatio ?? "";
        message.scriptEnabled = object.scriptEnabled ?? false;
        message.allowedPublishers = object.allowedPublishers?.map((e) => e) || [];
        return message;
    },
};
function createBaseRawParams() {
    return { baseDenom: "", baseMinGasPrice: "", contractSharedRevenueRatio: "", scriptEnabled: false };
}
exports.RawParams = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.baseDenom !== "") {
            writer.uint32(10).string(message.baseDenom);
        }
        if (message.baseMinGasPrice !== "") {
            writer.uint32(18).string(message.baseMinGasPrice);
        }
        if (message.contractSharedRevenueRatio !== "") {
            writer.uint32(26).string(message.contractSharedRevenueRatio);
        }
        if (message.scriptEnabled !== false) {
            writer.uint32(32).bool(message.scriptEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRawParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.baseDenom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.baseMinGasPrice = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.contractSharedRevenueRatio = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.scriptEnabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            baseDenom: isSet(object.baseDenom) ? gt.String(object.baseDenom) : "",
            baseMinGasPrice: isSet(object.baseMinGasPrice) ? gt.String(object.baseMinGasPrice) : "",
            contractSharedRevenueRatio: isSet(object.contractSharedRevenueRatio)
                ? gt.String(object.contractSharedRevenueRatio)
                : "",
            scriptEnabled: isSet(object.scriptEnabled) ? gt.Boolean(object.scriptEnabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.baseDenom !== "") {
            obj.baseDenom = message.baseDenom;
        }
        if (message.baseMinGasPrice !== "") {
            obj.baseMinGasPrice = message.baseMinGasPrice;
        }
        if (message.contractSharedRevenueRatio !== "") {
            obj.contractSharedRevenueRatio = message.contractSharedRevenueRatio;
        }
        if (message.scriptEnabled !== false) {
            obj.scriptEnabled = message.scriptEnabled;
        }
        return obj;
    },
    create(base) {
        return exports.RawParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRawParams();
        message.baseDenom = object.baseDenom ?? "";
        message.baseMinGasPrice = object.baseMinGasPrice ?? "";
        message.contractSharedRevenueRatio = object.contractSharedRevenueRatio ?? "";
        message.scriptEnabled = object.scriptEnabled ?? false;
        return message;
    },
};
function createBaseModule() {
    return { address: "", moduleName: "", abi: "", rawBytes: new Uint8Array(0), upgradePolicy: 0 };
}
exports.Module = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.moduleName !== "") {
            writer.uint32(18).string(message.moduleName);
        }
        if (message.abi !== "") {
            writer.uint32(26).string(message.abi);
        }
        if (message.rawBytes.length !== 0) {
            writer.uint32(34).bytes(message.rawBytes);
        }
        if (message.upgradePolicy !== 0) {
            writer.uint32(40).int32(message.upgradePolicy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseModule();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.moduleName = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.abi = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.rawBytes = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.upgradePolicy = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? gt.String(object.address) : "",
            moduleName: isSet(object.moduleName) ? gt.String(object.moduleName) : "",
            abi: isSet(object.abi) ? gt.String(object.abi) : "",
            rawBytes: isSet(object.rawBytes) ? bytesFromBase64(object.rawBytes) : new Uint8Array(0),
            upgradePolicy: isSet(object.upgradePolicy) ? upgradePolicyFromJSON(object.upgradePolicy) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.moduleName !== "") {
            obj.moduleName = message.moduleName;
        }
        if (message.abi !== "") {
            obj.abi = message.abi;
        }
        if (message.rawBytes.length !== 0) {
            obj.rawBytes = base64FromBytes(message.rawBytes);
        }
        if (message.upgradePolicy !== 0) {
            obj.upgradePolicy = upgradePolicyToJSON(message.upgradePolicy);
        }
        return obj;
    },
    create(base) {
        return exports.Module.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseModule();
        message.address = object.address ?? "";
        message.moduleName = object.moduleName ?? "";
        message.abi = object.abi ?? "";
        message.rawBytes = object.rawBytes ?? new Uint8Array(0);
        message.upgradePolicy = object.upgradePolicy ?? 0;
        return message;
    },
};
function createBaseChecksum() {
    return { address: "", moduleName: "", checksum: new Uint8Array(0) };
}
exports.Checksum = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.moduleName !== "") {
            writer.uint32(18).string(message.moduleName);
        }
        if (message.checksum.length !== 0) {
            writer.uint32(26).bytes(message.checksum);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChecksum();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.moduleName = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.checksum = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? gt.String(object.address) : "",
            moduleName: isSet(object.moduleName) ? gt.String(object.moduleName) : "",
            checksum: isSet(object.checksum) ? bytesFromBase64(object.checksum) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.moduleName !== "") {
            obj.moduleName = message.moduleName;
        }
        if (message.checksum.length !== 0) {
            obj.checksum = base64FromBytes(message.checksum);
        }
        return obj;
    },
    create(base) {
        return exports.Checksum.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseChecksum();
        message.address = object.address ?? "";
        message.moduleName = object.moduleName ?? "";
        message.checksum = object.checksum ?? new Uint8Array(0);
        return message;
    },
};
function createBaseResource() {
    return { address: "", structTag: "", moveResource: "", rawBytes: new Uint8Array(0) };
}
exports.Resource = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.structTag !== "") {
            writer.uint32(18).string(message.structTag);
        }
        if (message.moveResource !== "") {
            writer.uint32(26).string(message.moveResource);
        }
        if (message.rawBytes.length !== 0) {
            writer.uint32(34).bytes(message.rawBytes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.structTag = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.moveResource = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.rawBytes = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? gt.String(object.address) : "",
            structTag: isSet(object.structTag) ? gt.String(object.structTag) : "",
            moveResource: isSet(object.moveResource) ? gt.String(object.moveResource) : "",
            rawBytes: isSet(object.rawBytes) ? bytesFromBase64(object.rawBytes) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.structTag !== "") {
            obj.structTag = message.structTag;
        }
        if (message.moveResource !== "") {
            obj.moveResource = message.moveResource;
        }
        if (message.rawBytes.length !== 0) {
            obj.rawBytes = base64FromBytes(message.rawBytes);
        }
        return obj;
    },
    create(base) {
        return exports.Resource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResource();
        message.address = object.address ?? "";
        message.structTag = object.structTag ?? "";
        message.moveResource = object.moveResource ?? "";
        message.rawBytes = object.rawBytes ?? new Uint8Array(0);
        return message;
    },
};
function createBaseTableInfo() {
    return { address: "", keyType: "", valueType: "" };
}
exports.TableInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.keyType !== "") {
            writer.uint32(18).string(message.keyType);
        }
        if (message.valueType !== "") {
            writer.uint32(26).string(message.valueType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTableInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.keyType = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.valueType = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? gt.String(object.address) : "",
            keyType: isSet(object.keyType) ? gt.String(object.keyType) : "",
            valueType: isSet(object.valueType) ? gt.String(object.valueType) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.keyType !== "") {
            obj.keyType = message.keyType;
        }
        if (message.valueType !== "") {
            obj.valueType = message.valueType;
        }
        return obj;
    },
    create(base) {
        return exports.TableInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTableInfo();
        message.address = object.address ?? "";
        message.keyType = object.keyType ?? "";
        message.valueType = object.valueType ?? "";
        return message;
    },
};
function createBaseTableEntry() {
    return { address: "", key: "", value: "", keyBytes: new Uint8Array(0), valueBytes: new Uint8Array(0) };
}
exports.TableEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.key !== "") {
            writer.uint32(18).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        if (message.keyBytes.length !== 0) {
            writer.uint32(34).bytes(message.keyBytes);
        }
        if (message.valueBytes.length !== 0) {
            writer.uint32(42).bytes(message.valueBytes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTableEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.keyBytes = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.valueBytes = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet(object.address) ? gt.String(object.address) : "",
            key: isSet(object.key) ? gt.String(object.key) : "",
            value: isSet(object.value) ? gt.String(object.value) : "",
            keyBytes: isSet(object.keyBytes) ? bytesFromBase64(object.keyBytes) : new Uint8Array(0),
            valueBytes: isSet(object.valueBytes) ? bytesFromBase64(object.valueBytes) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.keyBytes.length !== 0) {
            obj.keyBytes = base64FromBytes(message.keyBytes);
        }
        if (message.valueBytes.length !== 0) {
            obj.valueBytes = base64FromBytes(message.valueBytes);
        }
        return obj;
    },
    create(base) {
        return exports.TableEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTableEntry();
        message.address = object.address ?? "";
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.keyBytes = object.keyBytes ?? new Uint8Array(0);
        message.valueBytes = object.valueBytes ?? new Uint8Array(0);
        return message;
    },
};
function createBaseUpgradePolicyProto() {
    return { policy: 0 };
}
exports.UpgradePolicyProto = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.policy !== 0) {
            writer.uint32(8).int32(message.policy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpgradePolicyProto();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.policy = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { policy: isSet(object.policy) ? upgradePolicyFromJSON(object.policy) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.policy !== 0) {
            obj.policy = upgradePolicyToJSON(message.policy);
        }
        return obj;
    },
    create(base) {
        return exports.UpgradePolicyProto.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpgradePolicyProto();
        message.policy = object.policy ?? 0;
        return message;
    },
};
function createBaseDexPair() {
    return { metadataQuote: "", metadataLp: "" };
}
exports.DexPair = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.metadataQuote !== "") {
            writer.uint32(10).string(message.metadataQuote);
        }
        if (message.metadataLp !== "") {
            writer.uint32(18).string(message.metadataLp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDexPair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.metadataQuote = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.metadataLp = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadataQuote: isSet(object.metadataQuote) ? gt.String(object.metadataQuote) : "",
            metadataLp: isSet(object.metadataLp) ? gt.String(object.metadataLp) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadataQuote !== "") {
            obj.metadataQuote = message.metadataQuote;
        }
        if (message.metadataLp !== "") {
            obj.metadataLp = message.metadataLp;
        }
        return obj;
    },
    create(base) {
        return exports.DexPair.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDexPair();
        message.metadataQuote = object.metadataQuote ?? "";
        message.metadataLp = object.metadataLp ?? "";
        return message;
    },
};
function createBaseExecuteAuthorizationItem() {
    return { moduleAddress: "", moduleName: "", functionNames: [] };
}
exports.ExecuteAuthorizationItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.moduleAddress !== "") {
            writer.uint32(10).string(message.moduleAddress);
        }
        if (message.moduleName !== "") {
            writer.uint32(18).string(message.moduleName);
        }
        for (const v of message.functionNames) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExecuteAuthorizationItem();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.moduleAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.moduleName = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.functionNames.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            moduleAddress: isSet(object.moduleAddress) ? gt.String(object.moduleAddress) : "",
            moduleName: isSet(object.moduleName) ? gt.String(object.moduleName) : "",
            functionNames: gt.Array.isArray(object?.functionNames)
                ? object.functionNames.map((e) => gt.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.moduleAddress !== "") {
            obj.moduleAddress = message.moduleAddress;
        }
        if (message.moduleName !== "") {
            obj.moduleName = message.moduleName;
        }
        if (message.functionNames?.length) {
            obj.functionNames = message.functionNames;
        }
        return obj;
    },
    create(base) {
        return exports.ExecuteAuthorizationItem.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExecuteAuthorizationItem();
        message.moduleAddress = object.moduleAddress ?? "";
        message.moduleName = object.moduleName ?? "";
        message.functionNames = object.functionNames?.map((e) => e) || [];
        return message;
    },
};
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (gt.Buffer) {
        return Uint8Array.from(gt.Buffer.from(b64, "base64"));
    }
    else {
        const bin = gt.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (gt.Buffer) {
        return gt.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(gt.String.fromCharCode(byte));
        });
        return gt.btoa(bin.join(""));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=types.js.map