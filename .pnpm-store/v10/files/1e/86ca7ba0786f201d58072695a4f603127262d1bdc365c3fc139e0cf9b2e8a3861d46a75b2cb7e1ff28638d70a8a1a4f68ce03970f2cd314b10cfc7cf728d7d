import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "minievm.evm.v1";
/** Params defines the set of move parameters. */
export interface Params {
    /** extra_eips defines the additional EIPs for the vm.Config */
    extraEips: bigint[];
    /**
     * It is a list of addresses with permission to distribute contracts,
     * and an empty list is interpreted as allowing anyone to distribute.
     */
    allowedPublishers: string[];
    /**
     * allow_custom_erc20 defines whether the chain allows custom erc20 tokens
     * to be registered on cosmos bank interface.
     */
    allowCustomErc20: boolean;
    allowedCustomErc20s: string[];
    /** fee_denom defines the fee denom for the evm transactions */
    feeDenom: string;
    /**
     * gas_refund_ratio defines the gas refund ratio for the evm transactions
     * If the gas refund ratio is 0, the gas refund is disabled.
     */
    gasRefundRatio: string;
    /**
     * num_retain_block_hashes defines the number of block hashes to retain
     * for the evm opcode `BLOCKHASH`.
     *
     * minimum is 256 and 0 means no limit.
     */
    numRetainBlockHashes: bigint;
}
/**
 * Log represents a contract log event. These events are generated by
 * the LOG opcode and stored/indexed by the node.
 */
export interface Log {
    /** address of the contract that generated the event */
    address: string;
    /** list of topics provided by the contract. */
    topics: string[];
    /** supplied by the contract, usually ABI-encoded */
    data: string;
}
export interface AccessTuple {
    /** Address of the contract that will be accessed during the transaction execution. */
    address: string;
    /**
     * A list of storage keys that the transaction will interact with within the specified contract.
     * These keys represent specific storage slots in the contract's storage that are accessed or modified.
     */
    storageKeys: string[];
}
export interface ERC721OriginTokenInfo {
    tokenOriginId: string;
    tokenUri: string;
}
export declare const Params: {
    encode(message: Params, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Params;
    fromJSON(object: any): Params;
    toJSON(message: Params): unknown;
    create(base?: DeepPartial<Params>): Params;
    fromPartial(object: DeepPartial<Params>): Params;
};
export declare const Log: {
    encode(message: Log, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Log;
    fromJSON(object: any): Log;
    toJSON(message: Log): unknown;
    create(base?: DeepPartial<Log>): Log;
    fromPartial(object: DeepPartial<Log>): Log;
};
export declare const AccessTuple: {
    encode(message: AccessTuple, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AccessTuple;
    fromJSON(object: any): AccessTuple;
    toJSON(message: AccessTuple): unknown;
    create(base?: DeepPartial<AccessTuple>): AccessTuple;
    fromPartial(object: DeepPartial<AccessTuple>): AccessTuple;
};
export declare const ERC721OriginTokenInfo: {
    encode(message: ERC721OriginTokenInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ERC721OriginTokenInfo;
    fromJSON(object: any): ERC721OriginTokenInfo;
    toJSON(message: ERC721OriginTokenInfo): unknown;
    create(base?: DeepPartial<ERC721OriginTokenInfo>): ERC721OriginTokenInfo;
    fromPartial(object: DeepPartial<ERC721OriginTokenInfo>): ERC721OriginTokenInfo;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
