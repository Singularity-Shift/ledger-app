{"version":3,"file":"index.iife.js","sources":["../../../node_modules/.pnpm/valibot@1.0.0_typescript@5.8.2/node_modules/valibot/dist/index.js","../src/env/hasWebviewProxy.ts","../src/env/isIframe.ts","../../../node_modules/.pnpm/better-promises@0.4.1/node_modules/better-promises/dist/index.js","../../toolkit/dist/index.js","../../transformers/dist/index.js","../../../node_modules/.pnpm/mitt@3.0.1/node_modules/mitt/dist/mitt.mjs","../src/events/createEmitter.ts","../src/events/emitEvent.ts","../../signals/dist/index.js","../src/debug.ts","../src/logger.ts","../src/events/emitter.ts","../../../node_modules/.pnpm/error-kid@0.0.7/node_modules/error-kid/dist/index.js","../src/errors.ts","../src/methods/postMessage.ts","../src/methods/targetOrigin.ts","../src/methods/postEvent.ts","../src/utils/request.ts","../src/launch-params/retrieveRawLaunchParams.ts","../src/launch-params/retrieveLaunchParams.ts","../src/env/isTMA.ts","../src/env/mockTelegramEnv.ts","../src/launch-params/retrieveRawInitData.ts","../src/methods/captureSameReq.ts","../src/utils/compareVersions.ts","../src/methods/supports.ts","../src/methods/createPostEvent.ts","../src/utils/invokeCustomMethod.ts","../src/resetPackageState.ts"],"sourcesContent":["// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message !== void 0) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values2, separator) {\n  const list = [...new Set(values2)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/entriesFromObjects/entriesFromObjects.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromObjects(schemas) {\n  const entries = {};\n  for (const schema of schemas) {\n    Object.assign(entries, schema.entries);\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = (\n  // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp\n  /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n);\nvar SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/gtValue/gtValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction gtValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"gt_value\",\n    reference: gtValue,\n    async: false,\n    expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value > this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ltValue/ltValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction ltValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"lt_value\",\n    reference: ltValue,\n    async: false,\n    expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value < this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValues/notValues.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValues(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_values\",\n    reference: notValues,\n    async: false,\n    expects: `!${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, paths) {\n  if (dataset.issues) {\n    for (const path of paths) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (\n            // @ts-expect-error\n            path[index] !== issue.path[index].key && // @ts-expect-error\n            (path[index] !== \"$\" || issue.path[index].type !== \"array\")\n          ) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/slug/slug.ts\n// @__NO_SIDE_EFFECTS__\nfunction slug(message) {\n  return {\n    kind: \"validation\",\n    type: \"slug\",\n    reference: slug,\n    async: false,\n    expects: null,\n    requirement: SLUG_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"slug\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/values/values.ts\n// @__NO_SIDE_EFFECTS__\nfunction values(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"values\",\n    reference: values,\n    async: false,\n    expects: `${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, path) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, path) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? (await discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  RFC_EMAIL_REGEX,\n  SLUG_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _getByteCount,\n  _getGraphemeCount,\n  _getStandardProps,\n  _getWordCount,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  args,\n  argsAsync,\n  array,\n  arrayAsync,\n  assert,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  checkItemsAsync,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  entriesFromObjects,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  exactOptional,\n  exactOptionalAsync,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  graphemes,\n  gtValue,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  ltValue,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxGraphemes,\n  maxLength,\n  maxSize,\n  maxValue,\n  maxWords,\n  metadata,\n  mimeType,\n  minBytes,\n  minGraphemes,\n  minLength,\n  minSize,\n  minValue,\n  minWords,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notGraphemes,\n  notLength,\n  notSize,\n  notValue,\n  notValues,\n  notWords,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  returns,\n  returnsAsync,\n  rfcEmail,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  slug,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  values,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_,\n  words\n};\n","import { looseObject, function as fn, is } from 'valibot';\n\n/**\n * Returns true in case, passed value contains path `TelegramWebviewProxy.postEvent` property and\n * `postEvent` is a function.\n * @param value - value to check.\n */\nexport function hasWebviewProxy<T>(value: T): value is T & {\n  TelegramWebviewProxy: {\n    postEvent: (...args: unknown[]) => unknown;\n  };\n} {\n  return is(\n    looseObject({ TelegramWebviewProxy: looseObject({ postEvent: fn() }) }),\n    value,\n  );\n}\n","/**\n * @see https://stackoverflow.com/a/326076\n * @returns True, if current environment is iframe.\n */\nexport function isIframe(): boolean {\n  try {\n    return window.self !== window.top;\n  } catch {\n    return true;\n  }\n}\n","var V = Object.defineProperty;\nvar Y = (r, t, e) => t in r ? V(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar y = (r, t, e) => Y(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nvar $ = Object.defineProperty, k = (r, t, e) => t in r ? $(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e, q = (r, t, e) => k(r, t + \"\", e);\nfunction z(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction P(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class c extends Error {\n    constructor(...s) {\n      const a = typeof t == \"function\" ? t(...s) : typeof t == \"string\" ? [t] : t || [];\n      super(...a), q(this, \"type\", e), this.name = r;\n    }\n  }\n  return Object.defineProperty(c, \"name\", { value: r }), [c, z(c, e)];\n}\nconst [G, M] = P(\"CancelledError\", \"Promise was canceled\"), [H, N] = P(\n  \"TimeoutError\",\n  (r, t) => [`Timeout reached: ${r}ms`, { cause: t }]\n), B = Symbol(\"Resolved\");\nfunction C(r) {\n  return Array.isArray(r) && r[0] === B;\n}\nfunction J(r) {\n  return [B, r];\n}\nfunction x(r, t) {\n  return r.reject = t.reject, r.abort = t.abort, r;\n}\nclass m extends Promise {\n  constructor(e, c) {\n    let o, s;\n    super((a, i) => {\n      let v, u;\n      typeof e == \"function\" ? (v = e, u = c) : u = e;\n      const d = [], j = (n) => (...h) => {\n        const p = n(...h);\n        return d.forEach((F) => F()), p;\n      }, g = new AbortController(), { signal: l } = g;\n      s = (n) => {\n        !l.aborted && g.abort(n);\n      };\n      const b = () => l.reason, w = (n) => {\n        const h = () => {\n          n(b());\n        };\n        l.addEventListener(\"abort\", h, !0);\n        const p = () => {\n          l.removeEventListener(\"abort\", h, !0);\n        };\n        return d.push(p), p;\n      }, D = j((n) => {\n        a(n), s(J(n));\n      });\n      o = j((n) => {\n        i(n), s(n);\n      }), u || (u = {});\n      const { abortSignal: f, rejectOnAbort: A = !0 } = u;\n      if (f)\n        if (f.aborted) {\n          const { reason: n } = f;\n          if (A)\n            return o(n);\n          s(n);\n        } else {\n          const n = () => {\n            s(f.reason);\n          };\n          f.addEventListener(\"abort\", n), d.push(() => {\n            f.removeEventListener(\"abort\", n);\n          });\n        }\n      A && w(i);\n      const { timeout: E } = u;\n      if (E) {\n        const n = setTimeout(() => {\n          s(new H(E));\n        }, E);\n        d.push(() => {\n          clearTimeout(n);\n        });\n      }\n      const L = () => l.aborted, S = () => C(b()), T = () => {\n        const n = b();\n        return C(n) ? n[1] : void 0;\n      };\n      try {\n        const n = v && v(D, o, {\n          abortReason: b,\n          abortSignal: l,\n          isAborted: L,\n          isResolved: S,\n          onAborted: w,\n          onResolved: (h) => w(() => {\n            S() && h(T());\n          }),\n          resolved: T,\n          throwIfAborted() {\n            if (L())\n              throw b();\n          }\n        });\n        n instanceof Promise && n.catch(o);\n      } catch (n) {\n        o(n);\n      }\n    });\n    /**\n     * Aborts the promise execution using the specified reason.\n     *\n     * Not that this method doesn't reject the promise but notifies the executor using its context.\n     * To perform the same operation but also reject the promise, use the `reject()` method.\n     * @param reason - abort reason.\n     * @see reject\n     */\n    y(this, \"abort\");\n    /**\n     * Rejects the initially created promise.\n     *\n     * This method not only aborts the signal passed to the executor, but also rejects the\n     * promise itself calling all chained listeners.\n     *\n     * The reason passed to the method is being passed as-is to the executor's context.\n     */\n    y(this, \"reject\");\n    this.abort = s, this.reject = o;\n  }\n  /**\n   * Creates a new AbortablePromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new m(async (o, s, a) => {\n      try {\n        o(await e(a));\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new m((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * Aborts the promise with the cancel error.\n   */\n  cancel() {\n    this.abort(new G());\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return x(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return x(super.then(e, c), this);\n  }\n}\nfunction I(r, t) {\n  return r.resolve = t.resolve, r;\n}\nclass R extends m {\n  constructor(e, c) {\n    let o, s;\n    typeof e == \"function\" ? (o = e, s = c) : s = e;\n    let a;\n    super((i, v, u) => {\n      a = i, o && o(i, v, u);\n    }, s);\n    /**\n     * Resolves the promise.\n     */\n    y(this, \"resolve\");\n    this.resolve = a;\n  }\n  /**\n   * Creates a new ManualPromise instance using an executor, resolving the promise when a result\n   * was returned.\n   * @param fn - function returning promise result.\n   * @param options - additional options.\n   */\n  static fn(e, c) {\n    return new R((o, s, a) => {\n      try {\n        Promise.resolve(e(a)).then(o, s);\n      } catch (i) {\n        s(i);\n      }\n    }, c);\n  }\n  static resolve(e) {\n    return this.fn(() => e);\n  }\n  /**\n   * @see Promise.reject\n   */\n  static reject(e) {\n    return new R((c, o) => {\n      o(e);\n    });\n  }\n  /**\n   * @see Promise.catch\n   */\n  catch(e) {\n    return this.then(void 0, e);\n  }\n  /**\n   * @see Promise.finally\n   */\n  finally(e) {\n    return I(super.finally(e), this);\n  }\n  /**\n   * @see Promise.then\n   */\n  then(e, c) {\n    return I(super.then(e, c), this);\n  }\n}\nexport {\n  m as AbortablePromise,\n  G as CancelledError,\n  R as ManualPromise,\n  H as TimeoutError,\n  M as isCancelledError,\n  C as isPromiseResolveResult,\n  N as isTimeoutError\n};\n//# sourceMappingURL=index.js.map\n","function y(o) {\n  return o.replace(/[A-Z]/g, (e) => `-${e.toLowerCase()}`);\n}\nfunction C(o) {\n  return o.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);\n}\nfunction S(o) {\n  return Object.entries(o).reduce((e, [r, t]) => (e[C(r)] = t, e), {});\n}\nfunction $(o) {\n  return o.replace(/_[a-z]/g, (e) => e[1].toUpperCase());\n}\nfunction h(o) {\n  return Object.entries(o).reduce((e, [r, t]) => (e[$(r)] = t, e), {});\n}\nfunction f(o) {\n  const e = h(o);\n  for (const r in e) {\n    const t = e[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (e[r] = Array.isArray(t) ? t.map(f) : f(t));\n  }\n  return e;\n}\nfunction k(o) {\n  return o.replace(/_([a-z])/g, (e, r) => `-${r.toLowerCase()}`);\n}\nfunction g(o) {\n  return `tapps/${o}`;\n}\nfunction w(o, e) {\n  sessionStorage.setItem(g(o), JSON.stringify(e));\n}\nfunction T(o) {\n  const e = sessionStorage.getItem(g(o));\n  try {\n    return e ? JSON.parse(e) : void 0;\n  } catch {\n  }\n}\nfunction L(...o) {\n  const e = o.flat(1);\n  return [\n    e.push.bind(e),\n    () => {\n      e.forEach((r) => {\n        r();\n      });\n    }\n  ];\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(o, e) {\n  e || (e = {});\n  const {\n    textColor: r,\n    bgColor: t,\n    shouldLog: s\n  } = e, c = s === void 0 ? !0 : s, d = typeof c == \"boolean\" ? () => c : c, u = (n, a, ...i) => {\n    if (a || d()) {\n      const l = \"font-weight:bold;padding:0 5px;border-radius:100px\", [b, m, p] = {\n        log: [\"#0089c3\", \"white\", \"INFO\"],\n        error: [\"#ff0000F0\", \"white\", \"ERR\"],\n        warn: [\"#D38E15\", \"white\", \"WARN\"]\n      }[n];\n      console[n](\n        `%c${p} ${Intl.DateTimeFormat(\"en-GB\", {\n          hour: \"2-digit\",\n          minute: \"2-digit\",\n          second: \"2-digit\",\n          fractionalSecondDigits: 3,\n          timeZone: \"UTC\"\n        }).format(/* @__PURE__ */ new Date())}%c %c${o}`,\n        `${l};background-color:${b};color:${m}`,\n        \"\",\n        `${l};${r ? `color:${r};` : \"\"}${t ? `background-color:${t}` : \"\"}`,\n        ...i\n      );\n    }\n  };\n  return [\n    [\"log\", \"forceLog\"],\n    [\"warn\", \"forceWarn\"],\n    [\"error\", \"forceError\"]\n  ].reduce((n, [a, i]) => (n[a] = u.bind(void 0, a, !1), n[i] = u.bind(void 0, a, !0), n), {});\n}\nexport {\n  y as camelToKebab,\n  C as camelToSnake,\n  S as camelToSnakeObjKeys,\n  L as createCbCollector,\n  O as createLogger,\n  f as deepSnakeToCamelObjKeys,\n  T as getStorageValue,\n  w as setStorageValue,\n  $ as snakeToCamel,\n  h as snakeToCamelObjKeys,\n  k as snakeToKebab\n};\n//# sourceMappingURL=index.js.map\n","var b;\n// @__NO_SIDE_EFFECTS__\nfunction N(e) {\n  return {\n    lang: (e == null ? void 0 : e.lang) ?? (b == null ? void 0 : b.lang),\n    message: e == null ? void 0 : e.message,\n    abortEarly: (e == null ? void 0 : e.abortEarly) ?? (b == null ? void 0 : b.abortEarly),\n    abortPipeEarly: (e == null ? void 0 : e.abortPipeEarly) ?? (b == null ? void 0 : b.abortPipeEarly)\n  };\n}\nvar D;\n// @__NO_SIDE_EFFECTS__\nfunction Z(e) {\n  return D == null ? void 0 : D.get(e);\n}\nvar P;\n// @__NO_SIDE_EFFECTS__\nfunction ee(e) {\n  return P == null ? void 0 : P.get(e);\n}\nvar j;\n// @__NO_SIDE_EFFECTS__\nfunction ne(e, n) {\n  var r;\n  return (r = j == null ? void 0 : j.get(e)) == null ? void 0 : r.get(n);\n}\n// @__NO_SIDE_EFFECTS__\nfunction re(e) {\n  var r, t;\n  const n = typeof e;\n  return n === \"string\" ? `\"${e}\"` : n === \"number\" || n === \"bigint\" || n === \"boolean\" ? `${e}` : n === \"object\" || n === \"function\" ? (e && ((t = (r = Object.getPrototypeOf(e)) == null ? void 0 : r.constructor) == null ? void 0 : t.name)) ?? \"null\" : n;\n}\nfunction f(e, n, r, t, s) {\n  const u = s && \"input\" in s ? s.input : r.value, i = (s == null ? void 0 : s.expected) ?? e.expects ?? null, l = (s == null ? void 0 : s.received) ?? /* @__PURE__ */ re(u), o = {\n    kind: e.kind,\n    type: e.type,\n    input: u,\n    expected: i,\n    received: l,\n    message: `Invalid ${n}: ${i ? `Expected ${i} but r` : \"R\"}eceived ${l}`,\n    requirement: e.requirement,\n    path: s == null ? void 0 : s.path,\n    issues: s == null ? void 0 : s.issues,\n    lang: t.lang,\n    abortEarly: t.abortEarly,\n    abortPipeEarly: t.abortPipeEarly\n  }, y = e.kind === \"schema\", p = (s == null ? void 0 : s.message) ?? e.message ?? /* @__PURE__ */ ne(e.reference, o.lang) ?? (y ? /* @__PURE__ */ ee(o.lang) : null) ?? t.message ?? /* @__PURE__ */ Z(o.lang);\n  p && (o.message = typeof p == \"function\" ? (\n    // @ts-expect-error\n    p(o)\n  ) : p), y && (r.typed = !1), r.issues ? r.issues.push(o) : r.issues = [o];\n}\n// @__NO_SIDE_EFFECTS__\nfunction h(e) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(n) {\n      return e[\"~run\"]({ value: n }, /* @__PURE__ */ N());\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction W(e, n) {\n  return Object.hasOwn(e, n) && n !== \"__proto__\" && n !== \"prototype\" && n !== \"constructor\";\n}\n// @__NO_SIDE_EFFECTS__\nfunction te(e, n) {\n  const r = [...new Set(e)];\n  return r.length > 1 ? `(${r.join(` ${n} `)})` : r[0] ?? \"never\";\n}\nvar se = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(e) {\n    super(e[0].message), this.name = \"ValiError\", this.issues = e;\n  }\n};\n// @__NO_SIDE_EFFECTS__\nfunction L(e, n) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: L,\n    async: !1,\n    expects: null,\n    requirement: e,\n    message: n,\n    \"~run\"(r, t) {\n      return r.typed && !this.requirement(r.value) && f(this, \"input\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction R(e) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: R,\n    async: !1,\n    expects: null,\n    requirement: Number.isInteger,\n    message: e,\n    \"~run\"(n, r) {\n      return n.typed && !this.requirement(n.value) && f(this, \"integer\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction d(e) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: d,\n    async: !1,\n    operation: e,\n    \"~run\"(n) {\n      return n.value = this.operation(n.value), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction U(e, n, r) {\n  return typeof e.default == \"function\" ? (\n    // @ts-expect-error\n    e.default(n, r)\n  ) : (\n    // @ts-expect-error\n    e.default\n  );\n}\n// @__NO_SIDE_EFFECTS__\nfunction ie(e, n) {\n  return !e[\"~run\"]({ value: n }, { abortEarly: !0 }).issues;\n}\n// @__NO_SIDE_EFFECTS__\nfunction _(e) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: _,\n    expects: \"boolean\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"boolean\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction z(e) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: z,\n    expects: \"Date\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return n.value instanceof Date ? isNaN(n.value) ? f(this, \"type\", n, r, {\n        received: '\"Invalid Date\"'\n      }) : n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction J(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: J,\n    expects: e.name,\n    async: !1,\n    class: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value instanceof this.class ? r.typed = !0 : f(this, \"type\", r, t), r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction A(e) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: A,\n    expects: \"unknown\",\n    async: !1,\n    getter: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return this.getter(n.value)[\"~run\"](n, r);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction k(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: k,\n    expects: \"Object\",\n    async: !1,\n    entries: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      var u;\n      const s = r.value;\n      if (s && typeof s == \"object\") {\n        r.typed = !0, r.value = {};\n        for (const i in this.entries) {\n          const l = this.entries[i];\n          if (i in s || (l.type === \"exact_optional\" || l.type === \"optional\" || l.type === \"nullish\") && // @ts-expect-error\n          l.default !== void 0) {\n            const o = i in s ? (\n              // @ts-expect-error\n              s[i]\n            ) : /* @__PURE__ */ U(l), y = l[\"~run\"]({ value: o }, t);\n            if (y.issues) {\n              const p = {\n                type: \"object\",\n                origin: \"value\",\n                input: s,\n                key: i,\n                value: o\n              };\n              for (const m of y.issues)\n                m.path ? m.path.unshift(p) : m.path = [p], (u = r.issues) == null || u.push(m);\n              if (r.issues || (r.issues = y.issues), t.abortEarly) {\n                r.typed = !1;\n                break;\n              }\n            }\n            y.typed || (r.typed = !1), r.value[i] = y.value;\n          } else if (l.type !== \"exact_optional\" && l.type !== \"optional\" && l.type !== \"nullish\" && (f(this, \"key\", r, t, {\n            input: void 0,\n            expected: `\"${i}\"`,\n            path: [\n              {\n                type: \"object\",\n                origin: \"key\",\n                input: s,\n                key: i,\n                // @ts-expect-error\n                value: s[i]\n              }\n            ]\n          }), t.abortEarly))\n            break;\n        }\n        if (!r.issues || !t.abortEarly)\n          for (const i in s)\n            /* @__PURE__ */ W(s, i) && !(i in this.entries) && (r.value[i] = s[i]);\n      } else\n        f(this, \"type\", r, t);\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction E(e) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: E,\n    expects: \"number\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"number\" && !isNaN(n.value) ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction c(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: c,\n    expects: `(${e.expects} | undefined)`,\n    async: !1,\n    wrapped: e,\n    default: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      return r.value === void 0 && (this.default !== void 0 && (r.value = /* @__PURE__ */ U(this, r, t)), r.value === void 0) ? (r.typed = !0, r) : this.wrapped[\"~run\"](r, t);\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction V(e, n, r) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: V,\n    expects: \"Object\",\n    async: !1,\n    key: e,\n    value: n,\n    message: r,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(t, s) {\n      var i, l;\n      const u = t.value;\n      if (u && typeof u == \"object\") {\n        t.typed = !0, t.value = {};\n        for (const o in u)\n          if (/* @__PURE__ */ W(u, o)) {\n            const y = u[o], p = this.key[\"~run\"]({ value: o }, s);\n            if (p.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"key\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of p.issues)\n                g.path = [S], (i = t.issues) == null || i.push(g);\n              if (t.issues || (t.issues = p.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            const m = this.value[\"~run\"](\n              { value: y },\n              s\n            );\n            if (m.issues) {\n              const S = {\n                type: \"object\",\n                origin: \"value\",\n                input: u,\n                key: o,\n                value: y\n              };\n              for (const g of m.issues)\n                g.path ? g.path.unshift(S) : g.path = [S], (l = t.issues) == null || l.push(g);\n              if (t.issues || (t.issues = m.issues), s.abortEarly) {\n                t.typed = !1;\n                break;\n              }\n            }\n            (!p.typed || !m.typed) && (t.typed = !1), p.typed && (t.value[p.value] = m.value);\n          }\n      } else\n        f(this, \"type\", t, s);\n      return t;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction a(e) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: a,\n    expects: \"string\",\n    async: !1,\n    message: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      return typeof n.value == \"string\" ? n.typed = !0 : f(this, \"type\", n, r), n;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction O(e) {\n  let n;\n  if (e)\n    for (const r of e)\n      n ? n.push(...r.issues) : n = r.issues;\n  return n;\n}\n// @__NO_SIDE_EFFECTS__\nfunction $(e, n) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: $,\n    expects: /* @__PURE__ */ te(\n      e.map((r) => r.expects),\n      \"|\"\n    ),\n    async: !1,\n    options: e,\n    message: n,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(r, t) {\n      let s, u, i;\n      for (const l of this.options) {\n        const o = l[\"~run\"]({ value: r.value }, t);\n        if (o.typed)\n          if (o.issues)\n            u ? u.push(o) : u = [o];\n          else {\n            s = o;\n            break;\n          }\n        else\n          i ? i.push(o) : i = [o];\n      }\n      if (s)\n        return s;\n      if (u) {\n        if (u.length === 1)\n          return u[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(u)\n        }), r.typed = !0;\n      } else {\n        if ((i == null ? void 0 : i.length) === 1)\n          return i[0];\n        f(this, \"type\", r, t, {\n          issues: /* @__PURE__ */ O(i)\n        });\n      }\n      return r;\n    }\n  };\n}\n// @__NO_SIDE_EFFECTS__\nfunction q() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: q,\n    expects: \"unknown\",\n    async: !1,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(e) {\n      return e.typed = !0, e;\n    }\n  };\n}\nfunction B(e, n, r) {\n  const t = e[\"~run\"]({ value: n }, /* @__PURE__ */ N(r));\n  if (t.issues)\n    throw new se(t.issues);\n  return t.value;\n}\n// @__NO_SIDE_EFFECTS__\nfunction v(...e) {\n  return {\n    ...e[0],\n    pipe: e,\n    get \"~standard\"() {\n      return /* @__PURE__ */ h(this);\n    },\n    \"~run\"(n, r) {\n      for (const t of e)\n        if (t.kind !== \"metadata\") {\n          if (n.issues && (t.kind === \"schema\" || t.kind === \"transformation\")) {\n            n.typed = !1;\n            break;\n          }\n          (!n.issues || !r.abortEarly && !r.abortPipeEarly) && (n = t[\"~run\"](n, r));\n        }\n      return n;\n    }\n  };\n}\nfunction ue(e) {\n  return e.replace(/_[a-z]/g, (n) => n[1].toUpperCase());\n}\nfunction ae(e) {\n  return Object.entries(e).reduce((n, [r, t]) => (n[ue(r)] = t, n), {});\n}\nfunction w(e) {\n  const n = ae(e);\n  for (const r in n) {\n    const t = n[r];\n    t && typeof t == \"object\" && !(t instanceof Date) && (n[r] = Array.isArray(t) ? t.map(w) : w(t));\n  }\n  return n;\n}\nfunction I(e) {\n  return /* @__PURE__ */ d((n) => e ? w(n) : n);\n}\nfunction M(e) {\n  return (n) => /* @__PURE__ */ v(\n    e,\n    I(n)\n  );\n}\nfunction T(e) {\n  return (n, r) => B(\n    /* @__PURE__ */ v(e, I(r)),\n    n\n  );\n}\nfunction oe() {\n  return /* @__PURE__ */ d(JSON.parse);\n}\nfunction C(e) {\n  const n = M(e);\n  return (r) => /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    oe(),\n    n(r)\n  );\n}\nfunction ce(e) {\n  return /* @__PURE__ */ d((n) => {\n    const r = {};\n    return new URLSearchParams(n).forEach((t, s) => {\n      const u = r[s];\n      Array.isArray(u) ? u.push(t) : u === void 0 ? r[s] = t : r[s] = [u, t];\n    }), B(e, r);\n  });\n}\nfunction K(e) {\n  return (n) => /* @__PURE__ */ v(\n    /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ J(URLSearchParams)]),\n    ce(e),\n    I(n)\n  );\n}\nconst Q = /* @__PURE__ */ c(/* @__PURE__ */ A(() => he())), le = /* @__PURE__ */ k({\n  id: /* @__PURE__ */ E(),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  type: /* @__PURE__ */ a(),\n  title: /* @__PURE__ */ a(),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), pe = /* @__PURE__ */ k({\n  added_to_attachment_menu: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  allows_write_to_pm: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  first_name: /* @__PURE__ */ a(),\n  id: /* @__PURE__ */ E(),\n  is_bot: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  is_premium: /* @__PURE__ */ c(/* @__PURE__ */ _()),\n  last_name: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  language_code: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  photo_url: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  username: /* @__PURE__ */ c(/* @__PURE__ */ a())\n}), fe = /* @__PURE__ */ k({\n  auth_date: /* @__PURE__ */ v(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ d((e) => new Date(Number(e) * 1e3)),\n    /* @__PURE__ */ z()\n  ),\n  can_send_after: /* @__PURE__ */ c(/* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d(Number), /* @__PURE__ */ R())),\n  chat: /* @__PURE__ */ c(/* @__PURE__ */ A(() => ye())),\n  chat_type: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  chat_instance: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  hash: /* @__PURE__ */ a(),\n  query_id: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  receiver: Q,\n  start_param: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  signature: /* @__PURE__ */ a(),\n  user: Q\n}), ye = C(le), he = C(pe), F = K(fe);\nfunction H(e) {\n  return /^#[\\da-f]{6}$/i.test(e);\n}\nfunction me(e) {\n  return /^#[\\da-f]{3}$/i.test(e);\n}\nfunction ge(e) {\n  const n = e.replace(/\\s/g, \"\").toLowerCase();\n  if (H(n))\n    return n;\n  if (me(n)) {\n    let t = \"#\";\n    for (let s = 0; s < 3; s += 1)\n      t += n[1 + s].repeat(2);\n    return t;\n  }\n  const r = n.match(/^rgb\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3})\\)$/) || n.match(/^rgba\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),\\d{1,3}\\)$/);\n  if (!r)\n    throw new Error(`Value \"${e}\" does not satisfy any of known RGB formats.`);\n  return r.slice(1).reduce((t, s) => t + parseInt(s, 10).toString(16).padStart(2, \"0\"), \"#\");\n}\nconst be = M(\n  /* @__PURE__ */ V(\n    /* @__PURE__ */ a(),\n    /* @__PURE__ */ v(\n      /* @__PURE__ */ $([/* @__PURE__ */ a(), /* @__PURE__ */ E()]),\n      /* @__PURE__ */ d((e) => typeof e == \"number\" ? `#${(e & 16777215).toString(16).padStart(6, \"0\")}` : e),\n      /* @__PURE__ */ L(H)\n    )\n  )\n), x = /* @__PURE__ */ c(\n  /* @__PURE__ */ v(/* @__PURE__ */ a(), /* @__PURE__ */ d((e) => e === \"1\"))\n), G = C(be()), de = /* @__PURE__ */ k({\n  tgWebAppBotInline: x,\n  tgWebAppData: /* @__PURE__ */ c(F()),\n  tgWebAppDefaultColors: /* @__PURE__ */ c(G()),\n  tgWebAppFullscreen: x,\n  tgWebAppPlatform: /* @__PURE__ */ a(),\n  tgWebAppShowSettings: x,\n  tgWebAppStartParam: /* @__PURE__ */ c(/* @__PURE__ */ a()),\n  tgWebAppThemeParams: G(),\n  tgWebAppVersion: /* @__PURE__ */ a()\n}), X = K(de), ke = T(F()), _e = T(X()), Se = /* @__PURE__ */ k({\n  eventType: /* @__PURE__ */ a(),\n  eventData: /* @__PURE__ */ c(/* @__PURE__ */ q())\n});\nfunction Y(e, n) {\n  return n || (n = (r, t) => JSON.stringify(t)), new URLSearchParams(\n    Object.entries(e).reduce((r, [t, s]) => (Array.isArray(s) ? r.push(...s.map((u) => [t, String(u)])) : s != null && r.push([\n      t,\n      s instanceof Date ? (s.getTime() / 1e3 | 0).toString() : typeof s == \"string\" || typeof s == \"number\" ? String(s) : typeof s == \"boolean\" ? s ? \"1\" : \"0\" : n(t, s)\n    ]), r), [])\n  ).toString();\n}\nfunction ve(e) {\n  return Y(e);\n}\nfunction Ee(e) {\n  return Y(e, (n, r) => n === \"tgWebAppData\" ? ve(r) : JSON.stringify(r));\n}\nfunction De(e) {\n  try {\n    return /* @__PURE__ */ ie(X(), e);\n  } catch {\n    return !1;\n  }\n}\nexport {\n  le as InitDataChatSchema,\n  fe as InitDataQuerySchema,\n  pe as InitDataUserSchema,\n  de as LaunchParamsSchema,\n  Se as MiniAppsMessageSchema,\n  I as conditionalSnakeKeys,\n  M as createCamelCaseGen,\n  T as createCamelCaseSchemaParserGen,\n  C as createJsonCamelCaseGen,\n  K as createQueryCamelCaseGen,\n  ye as initDataChatJson,\n  F as initDataQuery,\n  he as initDataUserJson,\n  De as isLaunchParamsQuery,\n  H as isRGB,\n  me as isRGBShort,\n  oe as jsonParse,\n  X as launchParamsQuery,\n  ke as parseInitDataQuery,\n  _e as parseLaunchParamsQuery,\n  ve as serializeInitDataQuery,\n  Ee as serializeLaunchParamsQuery,\n  Y as serializeToQuery,\n  be as themeParams,\n  ge as toRGB,\n  ce as transformQueryUsing\n};\n//# sourceMappingURL=index.js.map\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.mjs.map\n","import mitt, {\n  type Emitter,\n  type EventHandlerMap,\n  type EventType,\n  type Handler,\n} from 'mitt';\nimport type { If, IsNever, IsUndefined, Or } from '@telegram-apps/toolkit';\n\nexport type WildcardHandler<E> = Handler<{\n  [K in keyof E]: [K, If<Or<IsNever<E[K]>, IsUndefined<E[K]>>, void, E[K]>]\n}[keyof E]>;\n\nexport interface OnFn<E> {\n  /**\n   * Adds a new listener for the specified event.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */<K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): VoidFunction;\n  /**\n   * Adds a listener for all events.\n   * @param type - event name.\n   * @param handler - event listener.\n   * @param once - should listener be called only once.\n   * @returns Function to remove bound event listener.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): VoidFunction;\n}\n\nexport interface OffFn<E> {\n  /**\n   * Removes a listener for the specified event.\n   * @param type - event to listen.\n   * @param handler - event listener to remove.\n   * @param once - had this listener to be called only once.\n   */<K extends keyof E>(type: K, handler: Handler<E[K]>, once?: boolean): void;\n  /**\n   * Removes a listener for all events.\n   * @param type - event to stop listening.\n   * @param handler - event listener to remove.\n   * @param once - had this listener to be called only once.\n   */\n  (type: '*', handler: WildcardHandler<E>, once?: boolean): void;\n}\n\nexport interface EmitFn<E> {\n  <K extends keyof E>(type: K, event: E[K]): void;\n  <K extends keyof E>(type: undefined extends E[K] ? K : never): void;\n}\n\n/**\n * Creates a new enhanced event emitter.\n * @param onFirst - will be called when the first event was added.\n * @param onEmpty - will be called when emitter's listeners' map was emptied.\n */\nexport function createEmitter<E extends object>(\n  onFirst: VoidFunction,\n  onEmpty: VoidFunction,\n): [\n  on: OnFn<E>,\n  off: OffFn<E>,\n  emit: EmitFn<E>,\n  clear: VoidFunction\n] {\n  type EventMap = Map<\n    (...args: any) => void,\n    [handler: (...args: any) => void, once: boolean][]\n  >;\n\n  const emitter = (mitt as any as {\n    <E extends Record<EventType, unknown>>(all?: EventHandlerMap<E>): Emitter<E>;\n  })<E & Record<string | symbol, unknown>>();\n  const map = new Map<keyof E | '*', EventMap>();\n\n  const off: OffFn<E> = (event: keyof E | '*', handler: (...args: any) => void, once?: boolean) => {\n    once ||= false;\n\n    const eventMap: EventMap = map.get(event) || new Map();\n    map.set(event, eventMap);\n\n    const handlers = eventMap.get(handler) || [];\n    eventMap.set(handler, handlers);\n\n    const index = handlers.findIndex(item => item[1] === once);\n    if (index >= 0) {\n      // Remove the related handler.\n      emitter.off(event, handlers[index][0]);\n\n      // Remove the handler from the cache array.\n      handlers.splice(index, 1);\n\n      // If after removal, there are no handlers left, we should remove the entry from the cache.\n      !handlers.length && eventMap.delete(handler);\n      if (!eventMap.size) {\n        map.delete(event);\n        !map.size && onEmpty();\n      }\n    }\n  };\n\n  return [\n    function on(event: keyof E | '*', handler: (...args: any[]) => any, once?: boolean) {\n      !map.size && onFirst();\n\n      function cleanup() {\n        off(event as any, handler, once);\n      }\n\n      function fn(...args: any[]) {\n        once && cleanup();\n        if (event === '*') {\n          handler(args);\n        } else {\n          handler(...args);\n        }\n      }\n\n      emitter.on(event, fn);\n\n      // Add this handler to the cache, so we could remove it using the passed listener.\n      const eventMap = map.get(event) || new Map();\n      map.set(event, eventMap);\n\n      const handlers = eventMap.get(handler) || [];\n      eventMap.set(handler, handlers);\n      handlers.push([fn, once || false]);\n\n      return cleanup;\n    },\n    off,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    emitter.emit,\n    function offAll() {\n      const prevSize = emitter.all.size;\n      emitter.all.clear();\n      map.clear();\n      prevSize && onEmpty();\n    },\n  ];\n}\n","import type { EventWithoutPayload, EventWithPayload, EventPayload } from '@/events/types/index.js';\n\n/**\n * Emits an event without payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n */\nexport function emitEvent<E extends EventWithoutPayload>(eventType: E): void;\n\n/**\n * Emits an event with payload sent from the Telegram native application like it was sent in\n * a default web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends EventWithPayload>(\n  eventType: E,\n  eventData: EventPayload<E>,\n): void;\n\n/**\n * Emits an unknown event sent from the Telegram native application like it was sent in a default\n * web environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent<E extends string>(\n  eventType: E,\n  eventData: E extends EventWithoutPayload\n    ? never\n    : E extends EventWithPayload\n      ? EventPayload<E>\n      : unknown,\n): void;\n\n/**\n * Emits an event sent from the Telegram native application like it was sent in a default web\n * environment between two iframes.\n *\n * It dispatches a new MessageEvent and expects it to be handled via\n * the `window.addEventListener('message', ...)` call, as a developer would do it to handle\n * messages sent from the parent iframe.\n * @param eventType - event name.\n * @param eventData - event payload.\n */\nexport function emitEvent(eventType: string, eventData?: unknown): void {\n  window.dispatchEvent(new MessageEvent('message', {\n    data: JSON.stringify({ eventType, eventData }),\n    // We specify window.parent to imitate the case, the parent iframe sent us this event.\n    source: window.parent,\n  }));\n}\n","let r;\nfunction y(e, c) {\n  r && r.set(e, c) || c();\n}\nfunction m(e) {\n  if (r)\n    return e();\n  r = /* @__PURE__ */ new Map();\n  try {\n    e();\n  } finally {\n    r.forEach((c) => c()), r = void 0;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nfunction S(e, c) {\n  c || (c = {});\n  const g = c.equals || Object.is;\n  let u = [], s = e;\n  const i = (t) => {\n    if (!g(s, t)) {\n      const l = s;\n      s = t, y(o, () => {\n        [...u].forEach(([f, d]) => {\n          f(t, l), d && n(f, !0);\n        });\n      });\n    }\n  };\n  function a(t) {\n    const l = typeof t != \"object\" ? { once: t } : t;\n    return {\n      once: l.once || !1,\n      signal: l.signal || !1\n    };\n  }\n  const n = (t, l) => {\n    const f = a(l), d = u.findIndex(([h, p]) => h === t && p.once === f.once && p.signal === f.signal);\n    d >= 0 && u.splice(d, 1);\n  }, o = Object.assign(\n    function() {\n      return j(o), s;\n    },\n    {\n      destroy() {\n        u = [];\n      },\n      set: i,\n      reset() {\n        i(e);\n      },\n      sub(t, l) {\n        return u.push([t, a(l)]), () => n(t, l);\n      },\n      unsub: n,\n      unsubAll() {\n        u = u.filter((t) => t[1].signal);\n      }\n    }\n  );\n  return o;\n}\nconst b = [];\nfunction j(e) {\n  b.length && b[b.length - 1].add(e);\n}\n// @__NO_SIDE_EFFECTS__\nfunction x(e, c) {\n  let g = /* @__PURE__ */ new Set(), u;\n  function s() {\n    return u || (u = /* @__PURE__ */ S(a(), c));\n  }\n  function i() {\n    s().set(a());\n  }\n  function a() {\n    g.forEach((t) => {\n      t.unsub(i, { signal: !0 });\n    });\n    const n = /* @__PURE__ */ new Set();\n    let o;\n    b.push(n);\n    try {\n      o = e();\n    } finally {\n      b.pop();\n    }\n    return n.forEach((t) => {\n      t.sub(i, { signal: !0 });\n    }), g = n, o;\n  }\n  return Object.assign(function() {\n    return s()();\n  }, {\n    destroy() {\n      s().destroy();\n    },\n    sub(...n) {\n      return s().sub(...n);\n    },\n    unsub(...n) {\n      s().unsub(...n);\n    },\n    unsubAll(...n) {\n      s().unsubAll(...n);\n    }\n  });\n}\nexport {\n  m as batch,\n  x as computed,\n  S as signal\n};\n//# sourceMappingURL=index.js.map\n","import type { SubscribeListener } from '@/events/types/index.js';\nimport { off, on } from '@/events/emitter.js';\nimport { logger } from '@/logger.js';\n\n/**\n * The package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n */\nexport let debug = false;\n\nconst listener: SubscribeListener = event => {\n  logger().log('Event received:', event);\n};\n\n/**\n * Sets the package debug mode.\n *\n * Enabling debug mode leads to printing additional messages in the console related to the\n * processes inside the package.\n * @param value - enable debug mode.\n */\nexport function setDebug(value: boolean): void {\n  if (value !== debug) {\n    debug = value;\n    debug ? on('*', listener) : off('*', listener);\n  }\n}\n","import { createLogger, type Logger } from '@telegram-apps/toolkit';\nimport { signal } from '@telegram-apps/signals';\n\nimport { debug } from '@/debug.js';\n\nexport const logger = signal<Logger>(createLogger('Bridge', {\n  bgColor: '#9147ff',\n  textColor: 'white',\n  shouldLog() {\n    return debug;\n  },\n}));\n","import {\n  type InferOutput,\n  parse,\n  pipe,\n  string,\n  looseObject,\n  optional,\n  unknown,\n  number,\n  boolean,\n  nullish,\n  type BaseSchema,\n} from 'valibot';\nimport { jsonParse, MiniAppsMessageSchema, themeParams } from '@telegram-apps/transformers';\n\nimport { createEmitter } from '@/events/createEmitter.js';\nimport type { EventName, EventPayload, Events } from '@/events/types/index.js';\nimport { emitEvent } from '@/events/emitEvent.js';\nimport { logger } from '@/logger.js';\n\n/**\n * Transformers for problematic Mini Apps events.\n */\nconst transformers = {\n  clipboard_text_received: looseObject({\n    req_id: string(),\n    data: nullish(string()),\n  }),\n  custom_method_invoked: looseObject({\n    req_id: string(),\n    result: optional(unknown()),\n    error: optional(string()),\n  }),\n  popup_closed: nullish(\n    looseObject({ button_id: nullish(string(), () => undefined) }),\n    {},\n  ),\n  viewport_changed: looseObject({\n    height: number(),\n    width: nullish(number(), () => window.innerWidth),\n    is_state_stable: boolean(),\n    is_expanded: boolean(),\n  }),\n  theme_changed: looseObject({\n    theme_params: themeParams(),\n  }),\n} as const satisfies { [E in EventName]?: BaseSchema<unknown, EventPayload<E>, any> };\n\nfunction listener(event: MessageEvent): void {\n  // Ignore non-parent window messages.\n  if (event.source !== window.parent) {\n    return;\n  }\n\n  // Parse incoming event data.\n  let message: InferOutput<typeof MiniAppsMessageSchema>;\n  try {\n    message = parse(pipe(string(), jsonParse(), MiniAppsMessageSchema), event.data);\n  } catch {\n    // We ignore incorrect messages as they could be generated by any other code.\n    return;\n  }\n\n  const { eventType, eventData } = message;\n  const schema = transformers[eventType as keyof typeof transformers];\n\n  let data: unknown\n  try {\n    data = schema ? parse(schema, eventData) : eventData;\n  } catch (cause) {\n    return logger().forceError(\n      [\n        `An error occurred processing the \"${eventType}\" event from the Telegram application.`,\n        'Please, file an issue here:',\n        'https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose',\n      ].join('\\n'),\n      message,\n      cause,\n    );\n  }\n  emit(eventType as any, data);\n}\n\nexport const [\n  on,\n  off,\n  emit,\n  offAll,\n] = createEmitter<Events>(\n  () => {\n    const w = window as any;\n\n    // Define all functions responsible for receiving an event from the Telegram client.\n    // All these \"ports\" should narrow the communication way to a single specific one - the way\n    // accepted by the web version of Telegram between iframes.\n    const obj = { receiveEvent: emitEvent };\n    w.TelegramGameProxy_receiveEvent = emitEvent;\n    w.TelegramGameProxy = obj;\n    w.Telegram = { WebView: obj };\n\n    // Add a listener handling events sent from the Telegram web application and also events\n    // generated by the local emitEvent function.\n    // This handler should emit a new event using the library event emitter.\n    window.addEventListener('message', listener);\n  },\n  () => {\n    ['TelegramGameProxy_receiveEvent', 'TelegramGameProxy', 'Telegram'].forEach((prop) => {\n      delete (window as any)[prop];\n    });\n    window.removeEventListener('message', listener);\n  },\n);\n","var f = Object.defineProperty;\nvar u = (r, t, e) => t in r ? f(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;\nvar c = (r, t, e) => u(r, typeof t != \"symbol\" ? t + \"\" : t, e);\nfunction a(r, t) {\n  return (e) => e instanceof r && e.type === t;\n}\nfunction p(r, t) {\n  t || (t = []);\n  const e = Symbol(r);\n  class n extends Error {\n    constructor(...i) {\n      const o = typeof t == \"function\" ? t(...i) : typeof t == \"string\" ? [t] : t || [];\n      super(...o);\n      c(this, \"type\", e);\n      this.name = r;\n    }\n  }\n  return Object.defineProperty(n, \"name\", { value: r }), [n, a(n, e)];\n}\nfunction l(r, t, e) {\n  const n = Symbol(r);\n  class s extends p(r, e)[0] {\n    constructor(...o) {\n      super(...o);\n      c(this, \"data\");\n      c(this, \"type\", n);\n      this.data = t(...o);\n    }\n  }\n  return Object.defineProperty(s, \"name\", { value: r }), [s, a(s, n)];\n}\nexport {\n  p as errorClass,\n  l as errorClassWithData,\n  a as isErrorOfKind\n};\n//# sourceMappingURL=index.js.map\n","import { errorClass, errorClassWithData } from 'error-kid';\nimport type { Version } from '@telegram-apps/types';\n\nexport const [\n  MethodUnsupportedError,\n  isMethodUnsupportedError,\n] = errorClass<[method: string, version: Version]>(\n  'MethodUnsupportedError',\n  (method, version) => [\n    `Method \"${method}\" is unsupported in Mini Apps version ${version}`,\n  ],\n);\n\nexport const [\n  MethodParameterUnsupportedError,\n  isMethodMethodParameterUnsupportedError,\n] = errorClass<[method: string, param: string, version: Version]>(\n  'MethodParameterUnsupportedError',\n  (method, param, version) => [\n    `Parameter \"${param}\" of \"${method}\" method is unsupported in Mini Apps version ${version}`,\n  ],\n);\n\nexport const [\n  LaunchParamsRetrieveError,\n  isLaunchParamsRetrieveError,\n] = errorClassWithData<\n  { errors: [source: string, error: unknown][] },\n  [[source: string, error: unknown][]]\n>(\n  'LaunchParamsRetrieveError',\n  errors => ({ errors }),\n  errors => [\n    [\n      'Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?',\n      '📖 Refer to docs for more information:',\n      'https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment',\n      '',\n      'Collected errors:',\n      ...errors.map(([source, error]) => {\n        return `Source: ${source} / ${error instanceof Error ? error.message : String(error)}`;\n      }),\n    ].join('\\n'),\n  ],\n);\n\nexport const [\n  InvalidLaunchParamsError,\n  isInvalidLaunchParamsError,\n] = errorClass<[launchParams: string, cause: unknown]>(\n  'InvalidLaunchParamsError',\n  (launchParams, cause) => [\n    `Invalid value for launch params: ${launchParams}`,\n    { cause },\n  ],\n);\n\nexport const [UnknownEnvError, isUnknownEnvError] = errorClass('UnknownEnvError');\n\nexport const [\n  InvokeCustomMethodError,\n  isInvokeCustomMethodError,\n] = errorClass<[error: string]>(\n  'InvokeCustomMethodError',\n  error => [`Server returned error: ${error}`],\n);","import { signal } from '@telegram-apps/signals';\n\nimport { logger } from '@/logger.js';\n\nexport type PostMessage = typeof window.parent.postMessage;\n\n/**\n * Signal containing a custom implementation of the method to post a message to the parent\n * window. We usually use it to send a message in web versions of Telegram.\n *\n * Initially, this value contains a function behaving like the `window.parent.postMessage` method.\n */\nexport const postMessageImplementation = signal<PostMessage>((...args: any[]) => {\n  try {\n    window.parent.postMessage(...args as Parameters<PostMessage>);\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      logger().forceError(\n        'Unable to call window.parent.postMessage due to incorrectly configured target origin. Use the setTargetOrigin method to allow this origin to receive events',\n        e,\n      );\n    } else {\n      logger().forceError(e);\n    }\n  }\n});\n\n/**\n * Posts a message to the parent window. We usually use it to send a message in web versions of\n * Telegram.\n * @param args - `window.parent.postMessage` arguments.\n */\nexport const postMessage: PostMessage = (...args) => {\n  return postMessageImplementation()(...args as unknown as Parameters<PostMessage>);\n};\n","import { signal } from '@telegram-apps/signals';\n\nimport { logger } from '@/logger.js';\n\n/**\n * Target origin used by the `postEvent` method.\n *\n * You don't need to override this value until you know what you are doing.\n * @default 'https://web.telegram.org'\n */\nexport const targetOrigin = signal('https://web.telegram.org');\n\n/**\n * Sets a new target origin that is being used when calling the `postEvent` function in Telegram\n * web versions.\n * @param origin - allowed target origin value.\n * @see targetOrigin\n */\nexport function setTargetOrigin(origin: string) {\n  targetOrigin.set(origin);\n  logger().log('New target origin set', origin);\n}","import { is, looseObject, function as fn } from 'valibot';\n\nimport { logger } from '@/logger.js';\nimport { isIframe } from '@/env/isIframe.js';\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { UnknownEnvError } from '@/errors.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\n\nimport { postMessage } from './postMessage.js';\nimport { targetOrigin } from './targetOrigin.js';\n\nexport type PostEventFn = typeof postEvent;\n\n/**\n * Calls Mini Apps methods requiring parameters.\n * @param method - method name.\n * @param params - options along with params.\n * @throws {UnknownEnvError} The environment is unknown.\n */\nexport function postEvent<Method extends MethodNameWithRequiredParams>(\n  method: Method,\n  params: MethodParams<Method>,\n): void;\n\n/**\n * Calls Mini Apps methods accepting no parameters at all.\n * @param method - method name.\n * @throws {UnknownEnvError} The environment is unknown.\n */\nexport function postEvent(method: MethodNameWithoutParams): void;\n\n/**\n * Calls Mini Apps methods accepting optional parameters.\n * @param method - method name.\n * @param params - options along with params.\n * @throws {UnknownEnvError} The environment is unknown.\n */\nexport function postEvent<Method extends MethodNameWithOptionalParams>(\n  method: Method,\n  params?: MethodParams<Method>,\n): void;\n\nexport function postEvent(\n  eventType: MethodName,\n  eventData?: MethodParams<MethodName>,\n): void {\n  logger().log('Posting event:', eventData ? { eventType, eventData } : { eventType });\n\n  const w = window;\n\n  const message = JSON.stringify({ eventType, eventData });\n\n  // Telegram Web.\n  if (isIframe()) {\n    return postMessage(message, targetOrigin());\n  }\n\n  // Telegram for iOS, macOS, Android and Telegram Desktop.\n  if (hasWebviewProxy(w)) {\n    w.TelegramWebviewProxy.postEvent(eventType, JSON.stringify(eventData));\n    return;\n  }\n\n  // Telegram for Windows Phone or Android.\n  if (is(looseObject({ external: looseObject({ notify: fn() }) }), w)) {\n    w.external.notify(message);\n    return;\n  }\n\n  // Otherwise, the current environment is unknown, and we are not able to send event.\n  throw new UnknownEnvError();\n}\n","import {\n  createCbCollector,\n  type If,\n  type IsNever,\n} from '@telegram-apps/toolkit';\nimport { AbortablePromise, type PromiseOptions } from 'better-promises';\n\nimport { on } from '@/events/emitter.js';\nimport { postEvent, PostEventFn } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithOptionalParams,\n  MethodNameWithoutParams,\n  MethodNameWithRequiredParams,\n  MethodParams,\n} from '@/methods/types/index.js';\nimport type { EventName, EventPayload } from '@/events/types/events.js';\n\ntype AnyEventName = EventName | EventName[];\n\nexport type RequestCaptureFnEventsPayload<E extends EventName[]> = E extends (infer U extends EventName)[]\n  ? {\n    [K in U]: If<\n      IsNever<EventPayload<K>>,\n      { event: K },\n      { event: K; payload: EventPayload<K> }\n    >\n  }[U]\n  : never;\n\nexport type RequestCaptureEventsFn<E extends EventName[]> = (\n  payload: RequestCaptureFnEventsPayload<E>,\n) => boolean\n\nexport type RequestCaptureEventFn<E extends EventName> = If<\n  IsNever<EventPayload<E>>,\n  () => boolean,\n  (payload: EventPayload<E>) => boolean\n>;\n\nexport type RequestCaptureFn<E extends AnyEventName> = E extends EventName[]\n  ? RequestCaptureEventsFn<E>\n  : E extends EventName\n    ? RequestCaptureEventFn<E>\n    : never;\n\nexport interface RequestOptions<E extends AnyEventName>\n  extends Omit<PromiseOptions, 'rejectOnAbort'> {\n  /**\n   * Should return true if this event should be captured.\n   * The first compatible request will be captured if this property is omitted.\n   */\n  capture?: RequestCaptureFn<E>;\n  /**\n   * Custom function to call mini apps methods.\n   */\n  postEvent?: PostEventFn;\n}\n\nexport type RequestResult<E extends AnyEventName> =\n  E extends (infer U extends EventName)[]\n    ? U extends infer K extends EventName\n      ? If<IsNever<EventPayload<K>>, undefined, EventPayload<K>>\n      : never\n    : E extends EventName\n      ? If<IsNever<EventPayload<E>>, undefined, EventPayload<E>>\n      : never;\n\nexport type RequestFn = typeof request;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods, requiring parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithRequiredParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options: RequestOptions<E> & { params: MethodParams<M> },\n): AbortablePromise<RequestResult<E>>;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods with optional parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithOptionalParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): AbortablePromise<RequestResult<E>>;\n\n/**\n * Performs a request waiting for specified events to occur.\n *\n * This overriding is used for methods without parameters.\n * @param method - method name.\n * @param eventOrEvents - tracked event or events.\n * @param options - additional options.\n */\nexport function request<M extends MethodNameWithoutParams, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E>,\n): AbortablePromise<RequestResult<E>>;\n\nexport function request<M extends MethodName, E extends AnyEventName>(\n  method: M,\n  eventOrEvents: E,\n  options?: RequestOptions<E> & { params?: MethodParams<M> },\n): AbortablePromise<RequestResult<E>> {\n  options ||= {};\n  const { capture } = options;\n  const [addCleanup, cleanup] = createCbCollector();\n\n  return new AbortablePromise<RequestResult<E>>((resolve) => {\n    // We need to iterate over all tracked events and create their event listeners.\n    ((Array.isArray(eventOrEvents) ? eventOrEvents : [eventOrEvents])).forEach(event => {\n      // Each event listener waits for the event to occur.\n      // Then, if the capture function was passed, we should check if the event should be captured.\n      // If the function is omitted, we instantly capture the event.\n      addCleanup(\n        on(event, payload => {\n          if (!capture || (\n            Array.isArray(eventOrEvents)\n              ? (capture as RequestCaptureEventsFn<EventName[]>)({\n                event,\n                payload,\n              } as RequestCaptureFnEventsPayload<EventName[]>)\n              : (capture as RequestCaptureEventFn<EventName>)(payload)\n          )) {\n            resolve(payload as RequestResult<E>);\n          }\n        }),\n      );\n    });\n\n    (options.postEvent || postEvent)(method as any, (options as any).params);\n  }, options)\n    .finally(cleanup);\n}\n","import { isLaunchParamsQuery, parseLaunchParamsQuery } from '@telegram-apps/transformers';\nimport { getStorageValue, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { LaunchParamsRetrieveError } from '@/errors.js';\n\nconst SESSION_STORAGE_KEY = 'launchParams';\n\n/**\n * @param urlString - URL to extract launch parameters from.\n * @returns Launch parameters from the specified URL.\n * @throws Error if function was unable to extract launch parameters from the passed URL.\n */\nfunction fromURL(urlString: string): string {\n  return urlString\n    // Replace everything before this first hashtag or question sign.\n    .replace(/^[^?#]*[?#]/, '')\n    // Replace all hashtags and question signs to make it look like some search params.\n    .replace(/[?#]/g, '&');\n}\n\n/**\n * @returns Launch parameters in a raw format from any known source.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveRawLaunchParams(): string {\n  const errors: [source: string, error: unknown][] = [];\n  for (const [retrieve, source] of [\n    // Try to retrieve launch parameters from the current location. This method can return\n    // nothing in case, location was changed, and then the page was reloaded.\n    [() => fromURL(window.location.href), 'window.location.href'],\n    // Then, try using the lower level API - window.performance.\n    [() => {\n      const navigationEntry = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming | undefined;\n      return navigationEntry && fromURL(navigationEntry.name);\n    }, 'performance navigation entries'],\n    [() => getStorageValue<string>(SESSION_STORAGE_KEY), 'local storage'],\n  ] as const) {\n    const v = retrieve();\n    if (!v) {\n      errors.push([source, new Error('Source is empty')]);\n      continue;\n    }\n    if (isLaunchParamsQuery(v)) {\n      setStorageValue(SESSION_STORAGE_KEY, v);\n      return v;\n    }\n    try {\n      parseLaunchParamsQuery(v);\n    } catch (e) {\n      errors.push([source, e]);\n    }\n  }\n  throw new LaunchParamsRetrieveError(errors);\n}","import { LaunchParamsSchema, parseLaunchParamsQuery } from '@telegram-apps/transformers';\nimport {\n  type DeepConvertSnakeKeysToCamelCase,\n  deepSnakeToCamelObjKeys,\n} from '@telegram-apps/toolkit';\nimport type { InferOutput } from 'valibot';\n\nimport { retrieveRawLaunchParams } from '@/launch-params/retrieveRawLaunchParams.js';\n\nexport type RetrieveLPResult = InferOutput<typeof LaunchParamsSchema>;\nexport type RetrieveLPResultCamelCased =\n  DeepConvertSnakeKeysToCamelCase<InferOutput<typeof LaunchParamsSchema>>;\n\n/**\n * @returns Launch parameters from any known source.\n * @param camelCase - should the output be camel-cased.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveLaunchParams(camelCase?: false): RetrieveLPResult;\n\n/**\n * @returns Launch parameters from any known source.\n * @param camelCase - should the output be camel-cased.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveLaunchParams(camelCase: true): RetrieveLPResultCamelCased;\n\n/**\n * @returns Launch parameters from any known source.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch parameters. They are probably\n * invalid.\n */\nexport function retrieveLaunchParams(camelCase?: boolean):\n  | RetrieveLPResult\n  | RetrieveLPResultCamelCased {\n  const launchParams = parseLaunchParamsQuery(retrieveRawLaunchParams());\n  return camelCase ? deepSnakeToCamelObjKeys(launchParams) : launchParams;\n}\n","import { AbortablePromise, type PromiseOptions } from 'better-promises';\n\nimport { request } from '@/utils/request.js';\nimport { hasWebviewProxy } from '@/env/hasWebviewProxy.js';\nimport { retrieveLaunchParams } from '@/launch-params/retrieveLaunchParams.js';\n\n/**\n * Returns true if the current environment is Telegram Mini Apps.\n *\n * It uses the `retrieveLaunchParams` function to determine if the environment contains\n * launch parameters. In case it does, true will be returned.\n *\n * In case you need stricter checks, use async override of this function.\n */\nexport function isTMA(): boolean;\n\n/**\n * Returns promise with true if the current environment is Telegram Mini Apps.\n *\n * First of all, it checks if the current environment contains traits specific to the\n * Mini Apps environment.\n * Then, it attempts to call a Mini Apps method and waits for a response to be received.\n *\n * In case you need less strict checks, use sync override of this function.\n */\nexport function isTMA(type: 'complete', options?: PromiseOptions): AbortablePromise<boolean>\n\nexport function isTMA(\n  type?: 'complete',\n  options?: PromiseOptions,\n): boolean | AbortablePromise<boolean> {\n  if (!type) {\n    try {\n      retrieveLaunchParams();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  return AbortablePromise.fn(async context => {\n    if (hasWebviewProxy(window)) {\n      return true;\n    }\n    try {\n      await request('web_app_request_theme', 'theme_changed', context);\n      return true;\n    } catch {\n      return false;\n    }\n  }, options || { timeout: 100 });\n}\n","import { is, parse, pipe, string } from 'valibot';\nimport {\n  isLaunchParamsQuery,\n  jsonParse,\n  type LaunchParamsLike,\n  MiniAppsMessageSchema,\n  serializeLaunchParamsQuery,\n  parseLaunchParamsQuery,\n} from '@telegram-apps/transformers';\nimport { If, IsNever, setStorageValue } from '@telegram-apps/toolkit';\n\nimport { logger } from '@/logger.js';\nimport { isIframe } from '@/env/isIframe.js';\nimport type { MethodName, MethodParams } from '@/methods/types/index.js';\nimport { InvalidLaunchParamsError } from '@/errors.js';\nimport { postMessageImplementation } from '@/methods/postMessage.js';\n\n/**\n * Mocks the environment and imitates Telegram Mini Apps behavior.\n *\n * We usually use this function in the following cases:\n * 1. We are developing an application outside the Telegram environment and would like to imitate\n * the Telegram client in order to re-create the same communication behavior.\n * 2. We would like to intercept some Telegram Mini Apps methods' calls in order to enhance them\n * or write a custom behavior. It is extremely useful in some Telegram clients improperly handling\n * Mini Apps methods' calls and not even responding.\n *\n * Note that calling this function in Telegram web clients, the `postMessageImplementation` signal\n * value will be updated with a new one, enhancing previously set signal value to allow wrapping\n * the original `window.parent.postMessage` function. In other words, calling `mockTelegramEnv`\n * function N times, you will effectively wrap previously set implementation N times, so be\n * careful calling this function several times during a single lifecycle of the app. In case you\n * would like to avoid such kind of behavior, use the `resetPostMessage` option.\n */\nexport function mockTelegramEnv({ launchParams, onEvent, resetPostMessage }: {\n  /**\n   * Launch parameters to mock. They will be saved in the storage, so the SDK functions could\n   * retrieve them.\n   *\n   * Note that this value must have `tgWebAppData` presented in a raw format as long as you will\n   * need it when retrieving init data in this format. Otherwise, init data may be broken.\n   */\n  launchParams?:\n    | (Omit<LaunchParamsLike, 'tgWebAppData'> & { tgWebAppData?: string | URLSearchParams })\n    | string\n    | URLSearchParams;\n  /**\n   * Function that will be called if a Mini Apps method call was requested by the mini app.\n   *\n   * It receives a Mini Apps method name along with the passed payload.\n   *\n   * Note that using the `next` function, in non-web environments it uses the\n   * `window.TelegramWebviewProxy.postEvent`.\n   *\n   * Talking about the web versions of Telegram, the value is a bit more complex - it will\n   * equal to the value stored in the `postMessageImplementation` signal set previously. By default,\n   * this value contains a function utilizing the `window.parent.postMessage` method.\n   * @param event - event information.\n   * @param next - function to call the original method used to call a Mini Apps method.\n   */\n  onEvent?: (\n    event: {\n      [M in MethodName]: [M, If<IsNever<MethodParams<M>>, void, MethodParams<M>>]\n    }[MethodName] | [string, unknown],\n    next: () => void,\n  ) => void;\n  /**\n   * Removes all previously set enhancements of the `window.parent.postMessage` function set\n   * by other `mockTelegramEnv` calls.\n   * @default false\n   */\n  resetPostMessage?: boolean;\n} = {}): void {\n  if (launchParams) {\n    // If launch parameters were passed, save them in the session storage, so\n    // the retrieveLaunchParams function would return them.\n    const launchParamsQuery =\n      typeof launchParams === 'string' || launchParams instanceof URLSearchParams\n        ? launchParams.toString()\n        : (\n          // Here we have to trick serializeLaunchParamsQuery into thinking, it serializes a valid\n          // value. We are doing it because we are working with tgWebAppData presented as a\n          // string, not an object as serializeLaunchParamsQuery requires.\n          serializeLaunchParamsQuery({ ...launchParams, tgWebAppData: undefined })\n          // Then, we just append init data.\n          + (launchParams.tgWebAppData ? `&tgWebAppData=${encodeURIComponent(launchParams.tgWebAppData.toString())}` : '')\n        );\n\n    // Remember to check if launch params are valid.\n    if (!isLaunchParamsQuery(launchParamsQuery)) {\n      try {\n        parseLaunchParamsQuery(launchParamsQuery);\n      } catch (e) {\n        throw new InvalidLaunchParamsError(launchParamsQuery, e);\n      }\n    }\n    setStorageValue('launchParams', launchParamsQuery);\n  }\n\n  // Original postEvent firstly checks if the current environment is iframe.\n  // That's why we have a separate branch for this environment here too.\n  if (isIframe()) {\n    if (!onEvent) {\n      return;\n    }\n    const MiniAppsMessageJson = pipe(\n      string(),\n      jsonParse(),\n      MiniAppsMessageSchema,\n    );\n\n    // As long as the postEvent function uses the postMessage method, we should rewire it.\n    resetPostMessage && postMessageImplementation.reset();\n    const original = postMessageImplementation();\n    postMessageImplementation.set((...args) => {\n      const [message] = args;\n      const next = () => {\n        (original as any)(...args);\n      };\n\n      // Pass only Telegram Mini Apps events to the handler. All other calls should be passed\n      // to the original handler (window.parent.postMessage likely).\n      if (is(MiniAppsMessageJson, message)) {\n        const data = parse(MiniAppsMessageJson, message);\n        onEvent([data.eventType, data.eventData], next);\n      } else {\n        next();\n      }\n    });\n\n    return;\n  }\n\n  // In all other environments, it is enough to define window.TelegramWebviewProxy.postEvent.\n  const proxy = (window as any).TelegramWebviewProxy || {};\n  const postEventDefaulted = proxy.postEvent || (() => undefined);\n  (window as any).TelegramWebviewProxy = {\n    ...proxy,\n    postEvent(eventType: string, eventData: string) {\n      const next = () => {\n        postEventDefaulted(eventType, eventData);\n      };\n      onEvent\n        ? onEvent([eventType, eventData ? JSON.parse(eventData) : undefined], next)\n        : next();\n    },\n  };\n\n  logger().log('Environment was mocked by the mockTelegramEnv function');\n}\n","import { retrieveRawLaunchParams } from '@/launch-params/retrieveRawLaunchParams.js';\n\n/**\n * @returns Raw init data from any known source.\n * @throws {LaunchParamsRetrieveError} Unable to retrieve launch params from any known source.\n */\nexport function retrieveRawInitData(): string | undefined {\n  return new URLSearchParams(retrieveRawLaunchParams()).get('tgWebAppData') || undefined;\n}","type CaptureSameReqFn = (payload: { req_id: string }) => boolean;\n\n/**\n * Returns a function which can be used in `request` function `capture` property to capture\n * the event with the same request identifier.\n * @param reqId - request identifier.\n */\nexport function captureSameReq(reqId: string): CaptureSameReqFn {\n  return ({ req_id }) => req_id === reqId;\n}\n","import type { Version } from '@telegram-apps/types';\n\nfunction parts(a: Version): number[] {\n  return a.split('.').map(Number);\n}\n\n/**\n * @param a - first version.\n * @param b - second version.\n * @returns\n * - `1` if the version \"a\" is greater than \"b\".\n * - `0` the version \"a\" is equal to \"b\".\n * - `-1` the version \"a\" is lower than \"b\".\n */\nexport function compareVersions(a: Version, b: Version): number {\n  const aParts = parts(a);\n  const bParts = parts(b);\n  const len = Math.max(aParts.length, bParts.length);\n\n  // Iterate over each part of versions and compare them. In case, part is\n  // missing, assume its value is equal to 0.\n  for (let i = 0; i < len; i += 1) {\n    const aVal = aParts[i] || 0\n    const bVal = bParts[i] || 0;\n\n    if (aVal === bVal) {\n      continue;\n    }\n    return aVal > bVal ? 1 : -1;\n  }\n  return 0;\n}\n","import type { Version } from '@telegram-apps/types';\n\nimport { compareVersions } from '@/utils/compareVersions.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\n\n/**\n * Returns true if \"a\" version is less than or equal to \"b\" version.\n * @param a\n * @param b\n */\nfunction versionLessOrEqual(a: Version, b: Version): boolean {\n  return compareVersions(a, b) <= 0;\n}\n\n/**\n * Returns true in case, passed parameter in specified method is supported.\n * @param method - method name\n * @param param - method parameter\n * @param inVersion - platform version.\n */\nexport function supports<M extends MethodNameWithVersionedParams>(\n  method: M,\n  param: MethodVersionedParams<M>,\n  inVersion: Version,\n): boolean;\n\n/**\n * Returns true in case, specified method is supported in a passed version.\n * @param method - method name.\n * @param inVersion - platform version.\n */\nexport function supports(method: MethodName, inVersion: Version): boolean;\n\nexport function supports(\n  method: MethodName,\n  paramOrVersion: Version | string,\n  inVersion?: string,\n): boolean {\n  // Method name, parameter, target version.\n  if (typeof inVersion === 'string') {\n    if (method === 'web_app_open_link') {\n      if (paramOrVersion === 'try_instant_view') {\n        return versionLessOrEqual('6.4', inVersion);\n      }\n      if (paramOrVersion === 'try_browser') {\n        return versionLessOrEqual('7.6', inVersion);\n      }\n    }\n\n    if (method === 'web_app_set_header_color') {\n      if (paramOrVersion === 'color') {\n        return versionLessOrEqual('6.9', inVersion);\n      }\n    }\n\n    if (method === 'web_app_close' && paramOrVersion === 'return_back') {\n      return versionLessOrEqual('7.6', inVersion);\n    }\n\n    if (method === 'web_app_setup_main_button' && paramOrVersion === 'has_shine_effect') {\n      return versionLessOrEqual('7.10', inVersion);\n    }\n  }\n\n  switch (method) {\n    case 'web_app_open_tg_link':\n    case 'web_app_open_invoice':\n    case 'web_app_setup_back_button':\n    case 'web_app_set_background_color':\n    case 'web_app_set_header_color':\n    case 'web_app_trigger_haptic_feedback':\n      return versionLessOrEqual('6.1', paramOrVersion);\n    case 'web_app_open_popup':\n      return versionLessOrEqual('6.2', paramOrVersion);\n    case 'web_app_close_scan_qr_popup':\n    case 'web_app_open_scan_qr_popup':\n    case 'web_app_read_text_from_clipboard':\n      return versionLessOrEqual('6.4', paramOrVersion);\n    case 'web_app_switch_inline_query':\n      return versionLessOrEqual('6.7', paramOrVersion);\n    case 'web_app_invoke_custom_method':\n    case 'web_app_request_write_access':\n    case 'web_app_request_phone':\n      return versionLessOrEqual('6.9', paramOrVersion);\n    case 'web_app_setup_settings_button':\n      return versionLessOrEqual('6.10', paramOrVersion);\n    case 'web_app_biometry_get_info':\n    case 'web_app_biometry_open_settings':\n    case 'web_app_biometry_request_access':\n    case 'web_app_biometry_request_auth':\n    case 'web_app_biometry_update_token':\n      return versionLessOrEqual('7.2', paramOrVersion);\n    case 'web_app_setup_swipe_behavior':\n      return versionLessOrEqual('7.7', paramOrVersion);\n    case 'web_app_share_to_story':\n      return versionLessOrEqual('7.8', paramOrVersion);\n    case 'web_app_setup_secondary_button':\n    case 'web_app_set_bottom_bar_color':\n      return versionLessOrEqual('7.10', paramOrVersion);\n    case 'web_app_request_safe_area':\n    case 'web_app_request_content_safe_area':\n    case 'web_app_request_fullscreen':\n    case 'web_app_exit_fullscreen':\n    case 'web_app_set_emoji_status':\n    case 'web_app_add_to_home_screen':\n    case 'web_app_check_home_screen':\n    case 'web_app_request_emoji_status_access':\n    case 'web_app_check_location':\n    case 'web_app_open_location_settings':\n    case 'web_app_request_file_download':\n    case 'web_app_request_location':\n    case 'web_app_send_prepared_message':\n    case 'web_app_start_accelerometer':\n    case 'web_app_start_device_orientation':\n    case 'web_app_start_gyroscope':\n    case 'web_app_stop_accelerometer':\n    case 'web_app_stop_device_orientation':\n    case 'web_app_stop_gyroscope':\n    case 'web_app_toggle_orientation_lock':\n      return versionLessOrEqual('8.0', paramOrVersion);\n    default:\n      return [\n        'iframe_ready',\n        'iframe_will_reload',\n        'web_app_close',\n        'web_app_data_send',\n        'web_app_expand',\n        'web_app_open_link',\n        'web_app_ready',\n        'web_app_request_theme',\n        'web_app_request_viewport',\n        'web_app_setup_main_button',\n        'web_app_setup_closing_behavior',\n      ].includes(method);\n  }\n}\n","import { any, is, looseObject } from 'valibot';\nimport type { Version } from '@telegram-apps/types';\n\nimport { supports } from '@/methods/supports.js';\nimport { type PostEventFn, postEvent } from '@/methods/postEvent.js';\nimport type {\n  MethodName,\n  MethodNameWithVersionedParams,\n  MethodVersionedParams,\n} from '@/methods/types/index.js';\nimport { MethodParameterUnsupportedError, MethodUnsupportedError } from '@/errors.js';\nimport { logger } from '@/logger.js';\n\nexport type OnUnsupportedFn = (\n  data: { version: Version } & (\n    | { method: MethodName }\n    | {\n    [M in MethodNameWithVersionedParams]: {\n      method: M;\n      param: MethodVersionedParams<M>;\n    };\n  }[MethodNameWithVersionedParams]),\n) => void;\n\nexport type CreatePostEventMode = 'strict' | 'non-strict';\n\n/**\n * Creates a function that checks if the specified method and parameters are supported.\n *\n * If the method or parameters are unsupported, the `onUnsupported` function will be called.\n *\n * If `strict` or `non-strict` value was passed as the second argument, the function\n * will create its own `onUnsupported` function with behavior depending on the value passed.\n *\n * - Passing `strict` will make the function to throw a `MethodParameterUnsupportedError`\n * or a `MethodUnsupportedError` error.\n * - Passing `non-strict` will just warn you about something being unsupported.\n *\n * @param version - Telegram Mini Apps version.\n * @param onUnsupportedOrMode - function or strict mode. Default: `strict`\n */\nexport function createPostEvent(\n  version: Version,\n  onUnsupportedOrMode?: OnUnsupportedFn | CreatePostEventMode,\n): PostEventFn {\n  onUnsupportedOrMode ||= 'strict';\n  const onUnsupported: OnUnsupportedFn = typeof onUnsupportedOrMode === 'function'\n    ? onUnsupportedOrMode\n    : data => {\n      const { method, version } = data;\n      const error = 'param' in data\n        ? new MethodParameterUnsupportedError(method, data.param, version)\n        : new MethodUnsupportedError(method, version);\n\n      if (onUnsupportedOrMode === 'strict') {\n        throw error;\n      }\n      return logger().forceWarn(error.message);\n    };\n\n  return ((method: any, params: any) => {\n    // Firstly, check if the method is supported.\n    if (!supports(method, version)) {\n      return onUnsupported({ version, method });\n    }\n\n    // Method could use parameters, which are supported only in specific versions of Mini Apps.\n    // We are validating only those parameters, which are not backward compatible.\n    if (\n      method === 'web_app_set_header_color'\n      && is(looseObject({ color: any() }), params)\n      && !supports(method, 'color', version)\n    ) {\n      return onUnsupported({ version, method, param: 'color' });\n    }\n\n    return postEvent(method, params);\n  }) as PostEventFn;\n}\n","import { AbortablePromise } from 'better-promises';\n\nimport { captureSameReq } from '@/methods/captureSameReq.js';\nimport type { CustomMethodName, CustomMethodParams } from '@/methods/types/index.js';\nimport { InvokeCustomMethodError } from '@/errors.js';\n\nimport { request, type RequestOptions } from './request.js';\n\nexport type InvokeCustomMethodOptions = Omit<RequestOptions<'custom_method_invoked'>, 'capture'>;\nexport type InvokeCustomMethodFn = typeof invokeCustomMethod;\n\n/**\n * Invokes known custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod<M extends CustomMethodName>(\n  method: M,\n  params: CustomMethodParams<M>,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\n/**\n * Invokes unknown custom method. Returns method execution result.\n * @param method - method name.\n * @param params - method parameters.\n * @param requestId - request identifier.\n * @param options - additional options.\n * @throws {InvokeCustomMethodError} Invocation completed with some error.\n */\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown>;\n\nexport function invokeCustomMethod(\n  method: string,\n  params: object,\n  requestId: string,\n  options?: InvokeCustomMethodOptions,\n): AbortablePromise<unknown> {\n  return request('web_app_invoke_custom_method', 'custom_method_invoked', {\n    ...options || {},\n    params: { method, params, req_id: requestId },\n    capture: captureSameReq(requestId),\n  })\n    .then(({ result, error }) => {\n      if (error) {\n        throw new InvokeCustomMethodError(error);\n      }\n      return result;\n    });\n}\n","import { targetOrigin } from '@/methods/targetOrigin.js';\nimport { setDebug } from '@/debug.js';\nimport { offAll } from '@/events/emitter.js';\nimport { postMessageImplementation } from '@/methods/postMessage.js';\n\n/**\n * Resets the package state. Normally, you don't use this function in your application.\n * We are using it only for test purposes.\n */\nexport function resetPackageState() {\n  offAll();\n  setDebug(false);\n  [postMessageImplementation, targetOrigin].forEach(s => {\n    s.unsubAll();\n    s.reset();\n  });\n}"],"names":["store","getGlobalConfig","config2","store2","getGlobalMessage","lang","store3","getSchemaMessage","store4","getSpecificMessage","reference","_a","_stringify","input","type","_b","_addIssue","context","label","dataset","other","expected","received","issue","isSchema","message","_getStandardProps","value2","_isValidObjectKey","object2","key","ValiError","issues","getFallback","schema","getDefault","is","any","boolean","function_","looseObject","entries","valueSchema","valueDataset","pathItem","nullish","wrapped","default_","number","optional","string","unknown","parse","pipe","pipe2","item","hasWebviewProxy","value","fn","isIframe","V","Y","r","t","e","y","$","k","q","z","P","c","s","G","M","H","N","B","C","J","x","m","o","a","i","v","u","d","j","n","h","p","F","g","l","b","w","D","f","A","E","L","S","T","I","R","O","Z","ee","ne","re","W","te","se","U","ie","_","ue","ae","oe","ce","K","Q","he","le","pe","fe","ye","be","de","X","_e","Se","ve","Ee","De","mitt","createEmitter","onFirst","onEmpty","emitter","map","off","event","handler","once","eventMap","handlers","index","cleanup","args","prevSize","emitEvent","eventType","eventData","debug","listener","logger","setDebug","on","signal","createLogger","transformers","themeParams","jsonParse","MiniAppsMessageSchema","data","cause","emit","offAll","obj","prop","MethodUnsupportedError","isMethodUnsupportedError","errorClass","method","version","MethodParameterUnsupportedError","isMethodMethodParameterUnsupportedError","param","LaunchParamsRetrieveError","isLaunchParamsRetrieveError","errorClassWithData","errors","source","error","InvalidLaunchParamsError","isInvalidLaunchParamsError","launchParams","UnknownEnvError","isUnknownEnvError","InvokeCustomMethodError","isInvokeCustomMethodError","postMessageImplementation","postMessage","targetOrigin","setTargetOrigin","origin","postEvent","request","eventOrEvents","options","capture","addCleanup","createCbCollector","AbortablePromise","resolve","payload","SESSION_STORAGE_KEY","fromURL","urlString","retrieveRawLaunchParams","retrieve","navigationEntry","getStorageValue","isLaunchParamsQuery","setStorageValue","parseLaunchParamsQuery","retrieveLaunchParams","camelCase","deepSnakeToCamelObjKeys","isTMA","mockTelegramEnv","onEvent","resetPostMessage","launchParamsQuery","serializeLaunchParamsQuery","MiniAppsMessageJson","original","next","proxy","postEventDefaulted","retrieveRawInitData","captureSameReq","reqId","req_id","parts","compareVersions","aParts","bParts","len","aVal","bVal","versionLessOrEqual","supports","paramOrVersion","inVersion","createPostEvent","onUnsupportedOrMode","onUnsupported","params","invokeCustomMethod","requestId","result","resetPackageState"],"mappings":"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","x_google_ignoreList":[0,3,6,13]}