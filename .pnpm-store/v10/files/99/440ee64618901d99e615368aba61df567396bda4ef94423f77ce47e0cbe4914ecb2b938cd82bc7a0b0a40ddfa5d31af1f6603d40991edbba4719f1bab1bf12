"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v5.27.1
// source: opinit/ophost/v1/query.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcWebError = exports.GrpcWebImpl = exports.QueryBatchInfosDesc = exports.QueryNextL1SequenceDesc = exports.QueryClaimedDesc = exports.QueryParamsDesc = exports.QueryOutputProposalsDesc = exports.QueryOutputProposalDesc = exports.QueryLastFinalizedOutputDesc = exports.QueryTokenPairsDesc = exports.QueryTokenPairByL2DenomDesc = exports.QueryTokenPairByL1DenomDesc = exports.QueryBridgesDesc = exports.QueryBridgeDesc = exports.QueryDesc = exports.QueryClientImpl = exports.QueryBatchInfosResponse = exports.QueryBatchInfosRequest = exports.QueryNextL1SequenceResponse = exports.QueryNextL1SequenceRequest = exports.QueryClaimedResponse = exports.QueryClaimedRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryOutputProposalsResponse = exports.QueryOutputProposalsRequest = exports.QueryOutputProposalResponse = exports.QueryOutputProposalRequest = exports.QueryLastFinalizedOutputResponse = exports.QueryLastFinalizedOutputRequest = exports.QueryTokenPairsResponse = exports.QueryTokenPairsRequest = exports.QueryTokenPairByL2DenomResponse = exports.QueryTokenPairByL2DenomRequest = exports.QueryTokenPairByL1DenomResponse = exports.QueryTokenPairByL1DenomRequest = exports.QueryBridgesResponse = exports.QueryBridgesRequest = exports.QueryBridgeResponse = exports.QueryBridgeRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const grpc_web_1 = require("@improbable-eng/grpc-web");
const browser_headers_1 = require("browser-headers");
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const pagination_1 = require("../../../cosmos/base/query/v1beta1/pagination");
const types_1 = require("./types");
exports.protobufPackage = "opinit.ophost.v1";
function createBaseQueryBridgeRequest() {
    return { bridgeId: 0n };
}
exports.QueryBridgeRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBridgeRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        return obj;
    },
    create(base) {
        return exports.QueryBridgeRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBridgeRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        return message;
    },
};
function createBaseQueryBridgeResponse() {
    return { bridgeId: 0n, bridgeAddr: "", bridgeConfig: undefined };
}
exports.QueryBridgeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.bridgeAddr !== "") {
            writer.uint32(18).string(message.bridgeAddr);
        }
        if (message.bridgeConfig !== undefined) {
            types_1.BridgeConfig.encode(message.bridgeConfig, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBridgeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bridgeAddr = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.bridgeConfig = types_1.BridgeConfig.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            bridgeAddr: isSet(object.bridgeAddr) ? gt.String(object.bridgeAddr) : "",
            bridgeConfig: isSet(object.bridgeConfig) ? types_1.BridgeConfig.fromJSON(object.bridgeConfig) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.bridgeAddr !== "") {
            obj.bridgeAddr = message.bridgeAddr;
        }
        if (message.bridgeConfig !== undefined) {
            obj.bridgeConfig = types_1.BridgeConfig.toJSON(message.bridgeConfig);
        }
        return obj;
    },
    create(base) {
        return exports.QueryBridgeResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBridgeResponse();
        message.bridgeId = object.bridgeId ?? 0n;
        message.bridgeAddr = object.bridgeAddr ?? "";
        message.bridgeConfig =
            object.bridgeConfig !== undefined && object.bridgeConfig !== null
                ? types_1.BridgeConfig.fromPartial(object.bridgeConfig)
                : undefined;
        return message;
    },
};
function createBaseQueryBridgesRequest() {
    return { pagination: undefined };
}
exports.QueryBridgesRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBridgesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryBridgesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBridgesRequest();
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryBridgesResponse() {
    return { bridges: [], pagination: undefined };
}
exports.QueryBridgesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.bridges) {
            exports.QueryBridgeResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBridgesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bridges.push(exports.QueryBridgeResponse.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridges: gt.Array.isArray(object?.bridges)
                ? object.bridges.map((e) => exports.QueryBridgeResponse.fromJSON(e))
                : [],
            pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridges?.length) {
            obj.bridges = message.bridges.map((e) => exports.QueryBridgeResponse.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryBridgesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBridgesResponse();
        message.bridges = object.bridges?.map((e) => exports.QueryBridgeResponse.fromPartial(e)) || [];
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageResponse.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryTokenPairByL1DenomRequest() {
    return { bridgeId: 0n, l1Denom: "" };
}
exports.QueryTokenPairByL1DenomRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.l1Denom !== "") {
            writer.uint32(18).string(message.l1Denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTokenPairByL1DenomRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.l1Denom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            l1Denom: isSet(object.l1Denom) ? gt.String(object.l1Denom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.l1Denom !== "") {
            obj.l1Denom = message.l1Denom;
        }
        return obj;
    },
    create(base) {
        return exports.QueryTokenPairByL1DenomRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTokenPairByL1DenomRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        message.l1Denom = object.l1Denom ?? "";
        return message;
    },
};
function createBaseQueryTokenPairByL1DenomResponse() {
    return { tokenPair: undefined };
}
exports.QueryTokenPairByL1DenomResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tokenPair !== undefined) {
            types_1.TokenPair.encode(message.tokenPair, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTokenPairByL1DenomResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.tokenPair = types_1.TokenPair.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { tokenPair: isSet(object.tokenPair) ? types_1.TokenPair.fromJSON(object.tokenPair) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenPair !== undefined) {
            obj.tokenPair = types_1.TokenPair.toJSON(message.tokenPair);
        }
        return obj;
    },
    create(base) {
        return exports.QueryTokenPairByL1DenomResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTokenPairByL1DenomResponse();
        message.tokenPair =
            object.tokenPair !== undefined && object.tokenPair !== null
                ? types_1.TokenPair.fromPartial(object.tokenPair)
                : undefined;
        return message;
    },
};
function createBaseQueryTokenPairByL2DenomRequest() {
    return { bridgeId: 0n, l2Denom: "" };
}
exports.QueryTokenPairByL2DenomRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.l2Denom !== "") {
            writer.uint32(18).string(message.l2Denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTokenPairByL2DenomRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.l2Denom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            l2Denom: isSet(object.l2Denom) ? gt.String(object.l2Denom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.l2Denom !== "") {
            obj.l2Denom = message.l2Denom;
        }
        return obj;
    },
    create(base) {
        return exports.QueryTokenPairByL2DenomRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTokenPairByL2DenomRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        message.l2Denom = object.l2Denom ?? "";
        return message;
    },
};
function createBaseQueryTokenPairByL2DenomResponse() {
    return { tokenPair: undefined };
}
exports.QueryTokenPairByL2DenomResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tokenPair !== undefined) {
            types_1.TokenPair.encode(message.tokenPair, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTokenPairByL2DenomResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.tokenPair = types_1.TokenPair.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { tokenPair: isSet(object.tokenPair) ? types_1.TokenPair.fromJSON(object.tokenPair) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenPair !== undefined) {
            obj.tokenPair = types_1.TokenPair.toJSON(message.tokenPair);
        }
        return obj;
    },
    create(base) {
        return exports.QueryTokenPairByL2DenomResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTokenPairByL2DenomResponse();
        message.tokenPair =
            object.tokenPair !== undefined && object.tokenPair !== null
                ? types_1.TokenPair.fromPartial(object.tokenPair)
                : undefined;
        return message;
    },
};
function createBaseQueryTokenPairsRequest() {
    return { bridgeId: 0n, pagination: undefined };
}
exports.QueryTokenPairsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTokenPairsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryTokenPairsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTokenPairsRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryTokenPairsResponse() {
    return { tokenPairs: [], pagination: undefined };
}
exports.QueryTokenPairsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.tokenPairs) {
            types_1.TokenPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTokenPairsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.tokenPairs.push(types_1.TokenPair.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tokenPairs: gt.Array.isArray(object?.tokenPairs)
                ? object.tokenPairs.map((e) => types_1.TokenPair.fromJSON(e))
                : [],
            pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tokenPairs?.length) {
            obj.tokenPairs = message.tokenPairs.map((e) => types_1.TokenPair.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryTokenPairsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTokenPairsResponse();
        message.tokenPairs = object.tokenPairs?.map((e) => types_1.TokenPair.fromPartial(e)) || [];
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageResponse.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryLastFinalizedOutputRequest() {
    return { bridgeId: 0n };
}
exports.QueryLastFinalizedOutputRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryLastFinalizedOutputRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        return obj;
    },
    create(base) {
        return exports.QueryLastFinalizedOutputRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryLastFinalizedOutputRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        return message;
    },
};
function createBaseQueryLastFinalizedOutputResponse() {
    return { outputIndex: 0n, outputProposal: undefined };
}
exports.QueryLastFinalizedOutputResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.outputIndex !== 0n) {
            if (BigInt.asUintN(64, message.outputIndex) !== message.outputIndex) {
                throw new gt.Error("value provided for field message.outputIndex of type uint64 too large");
            }
            writer.uint32(8).uint64(message.outputIndex.toString());
        }
        if (message.outputProposal !== undefined) {
            types_1.Output.encode(message.outputProposal, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryLastFinalizedOutputResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.outputIndex = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.outputProposal = types_1.Output.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            outputIndex: isSet(object.outputIndex) ? BigInt(object.outputIndex) : 0n,
            outputProposal: isSet(object.outputProposal) ? types_1.Output.fromJSON(object.outputProposal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.outputIndex !== 0n) {
            obj.outputIndex = message.outputIndex.toString();
        }
        if (message.outputProposal !== undefined) {
            obj.outputProposal = types_1.Output.toJSON(message.outputProposal);
        }
        return obj;
    },
    create(base) {
        return exports.QueryLastFinalizedOutputResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryLastFinalizedOutputResponse();
        message.outputIndex = object.outputIndex ?? 0n;
        message.outputProposal =
            object.outputProposal !== undefined && object.outputProposal !== null
                ? types_1.Output.fromPartial(object.outputProposal)
                : undefined;
        return message;
    },
};
function createBaseQueryOutputProposalRequest() {
    return { bridgeId: 0n, outputIndex: 0n };
}
exports.QueryOutputProposalRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.outputIndex !== 0n) {
            if (BigInt.asUintN(64, message.outputIndex) !== message.outputIndex) {
                throw new gt.Error("value provided for field message.outputIndex of type uint64 too large");
            }
            writer.uint32(16).uint64(message.outputIndex.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryOutputProposalRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.outputIndex = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            outputIndex: isSet(object.outputIndex) ? BigInt(object.outputIndex) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.outputIndex !== 0n) {
            obj.outputIndex = message.outputIndex.toString();
        }
        return obj;
    },
    create(base) {
        return exports.QueryOutputProposalRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryOutputProposalRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        message.outputIndex = object.outputIndex ?? 0n;
        return message;
    },
};
function createBaseQueryOutputProposalResponse() {
    return { bridgeId: 0n, outputIndex: 0n, outputProposal: undefined };
}
exports.QueryOutputProposalResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.outputIndex !== 0n) {
            if (BigInt.asUintN(64, message.outputIndex) !== message.outputIndex) {
                throw new gt.Error("value provided for field message.outputIndex of type uint64 too large");
            }
            writer.uint32(16).uint64(message.outputIndex.toString());
        }
        if (message.outputProposal !== undefined) {
            types_1.Output.encode(message.outputProposal, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryOutputProposalResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.outputIndex = longToBigint(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.outputProposal = types_1.Output.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            outputIndex: isSet(object.outputIndex) ? BigInt(object.outputIndex) : 0n,
            outputProposal: isSet(object.outputProposal) ? types_1.Output.fromJSON(object.outputProposal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.outputIndex !== 0n) {
            obj.outputIndex = message.outputIndex.toString();
        }
        if (message.outputProposal !== undefined) {
            obj.outputProposal = types_1.Output.toJSON(message.outputProposal);
        }
        return obj;
    },
    create(base) {
        return exports.QueryOutputProposalResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryOutputProposalResponse();
        message.bridgeId = object.bridgeId ?? 0n;
        message.outputIndex = object.outputIndex ?? 0n;
        message.outputProposal =
            object.outputProposal !== undefined && object.outputProposal !== null
                ? types_1.Output.fromPartial(object.outputProposal)
                : undefined;
        return message;
    },
};
function createBaseQueryOutputProposalsRequest() {
    return { bridgeId: 0n, pagination: undefined };
}
exports.QueryOutputProposalsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryOutputProposalsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryOutputProposalsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryOutputProposalsRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryOutputProposalsResponse() {
    return { outputProposals: [], pagination: undefined };
}
exports.QueryOutputProposalsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.outputProposals) {
            exports.QueryOutputProposalResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryOutputProposalsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.outputProposals.push(exports.QueryOutputProposalResponse.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            outputProposals: gt.Array.isArray(object?.outputProposals)
                ? object.outputProposals.map((e) => exports.QueryOutputProposalResponse.fromJSON(e))
                : [],
            pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.outputProposals?.length) {
            obj.outputProposals = message.outputProposals.map((e) => exports.QueryOutputProposalResponse.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryOutputProposalsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryOutputProposalsResponse();
        message.outputProposals =
            object.outputProposals?.map((e) => exports.QueryOutputProposalResponse.fromPartial(e)) || [];
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageResponse.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryParamsRequest() {
    return {};
}
exports.QueryParamsRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.QueryParamsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
    },
};
function createBaseQueryParamsResponse() {
    return { params: undefined };
}
exports.QueryParamsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== undefined) {
            types_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = types_1.Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet(object.params) ? types_1.Params.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = types_1.Params.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return exports.QueryParamsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params =
            object.params !== undefined && object.params !== null ? types_1.Params.fromPartial(object.params) : undefined;
        return message;
    },
};
function createBaseQueryClaimedRequest() {
    return { bridgeId: 0n, withdrawalHash: new Uint8Array(0) };
}
exports.QueryClaimedRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.withdrawalHash.length !== 0) {
            writer.uint32(18).bytes(message.withdrawalHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClaimedRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.withdrawalHash = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            withdrawalHash: isSet(object.withdrawalHash)
                ? bytesFromBase64(object.withdrawalHash)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.withdrawalHash.length !== 0) {
            obj.withdrawalHash = base64FromBytes(message.withdrawalHash);
        }
        return obj;
    },
    create(base) {
        return exports.QueryClaimedRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryClaimedRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        message.withdrawalHash = object.withdrawalHash ?? new Uint8Array(0);
        return message;
    },
};
function createBaseQueryClaimedResponse() {
    return { claimed: false };
}
exports.QueryClaimedResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.claimed !== false) {
            writer.uint32(8).bool(message.claimed);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClaimedResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.claimed = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { claimed: isSet(object.claimed) ? gt.Boolean(object.claimed) : false };
    },
    toJSON(message) {
        const obj = {};
        if (message.claimed !== false) {
            obj.claimed = message.claimed;
        }
        return obj;
    },
    create(base) {
        return exports.QueryClaimedResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryClaimedResponse();
        message.claimed = object.claimed ?? false;
        return message;
    },
};
function createBaseQueryNextL1SequenceRequest() {
    return { bridgeId: 0n };
}
exports.QueryNextL1SequenceRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNextL1SequenceRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        return obj;
    },
    create(base) {
        return exports.QueryNextL1SequenceRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryNextL1SequenceRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        return message;
    },
};
function createBaseQueryNextL1SequenceResponse() {
    return { nextL1Sequence: 0n };
}
exports.QueryNextL1SequenceResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nextL1Sequence !== 0n) {
            if (BigInt.asUintN(64, message.nextL1Sequence) !== message.nextL1Sequence) {
                throw new gt.Error("value provided for field message.nextL1Sequence of type uint64 too large");
            }
            writer.uint32(8).uint64(message.nextL1Sequence.toString());
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNextL1SequenceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.nextL1Sequence = longToBigint(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { nextL1Sequence: isSet(object.nextL1Sequence) ? BigInt(object.nextL1Sequence) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.nextL1Sequence !== 0n) {
            obj.nextL1Sequence = message.nextL1Sequence.toString();
        }
        return obj;
    },
    create(base) {
        return exports.QueryNextL1SequenceResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryNextL1SequenceResponse();
        message.nextL1Sequence = object.nextL1Sequence ?? 0n;
        return message;
    },
};
function createBaseQueryBatchInfosRequest() {
    return { bridgeId: 0n, pagination: undefined };
}
exports.QueryBatchInfosRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.bridgeId !== 0n) {
            if (BigInt.asUintN(64, message.bridgeId) !== message.bridgeId) {
                throw new gt.Error("value provided for field message.bridgeId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.bridgeId.toString());
        }
        if (message.pagination !== undefined) {
            pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBatchInfosRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bridgeId = longToBigint(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? BigInt(object.bridgeId) : 0n,
            pagination: isSet(object.pagination) ? pagination_1.PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bridgeId !== 0n) {
            obj.bridgeId = message.bridgeId.toString();
        }
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryBatchInfosRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBatchInfosRequest();
        message.bridgeId = object.bridgeId ?? 0n;
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageRequest.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
function createBaseQueryBatchInfosResponse() {
    return { batchInfos: [], pagination: undefined };
}
exports.QueryBatchInfosResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.batchInfos) {
            types_1.BatchInfoWithOutput.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBatchInfosResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.batchInfos.push(types_1.BatchInfoWithOutput.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            batchInfos: gt.Array.isArray(object?.batchInfos)
                ? object.batchInfos.map((e) => types_1.BatchInfoWithOutput.fromJSON(e))
                : [],
            pagination: isSet(object.pagination) ? pagination_1.PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.batchInfos?.length) {
            obj.batchInfos = message.batchInfos.map((e) => types_1.BatchInfoWithOutput.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = pagination_1.PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return exports.QueryBatchInfosResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBatchInfosResponse();
        message.batchInfos = object.batchInfos?.map((e) => types_1.BatchInfoWithOutput.fromPartial(e)) || [];
        message.pagination =
            object.pagination !== undefined && object.pagination !== null
                ? pagination_1.PageResponse.fromPartial(object.pagination)
                : undefined;
        return message;
    },
};
class QueryClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.Bridge = this.Bridge.bind(this);
        this.Bridges = this.Bridges.bind(this);
        this.TokenPairByL1Denom = this.TokenPairByL1Denom.bind(this);
        this.TokenPairByL2Denom = this.TokenPairByL2Denom.bind(this);
        this.TokenPairs = this.TokenPairs.bind(this);
        this.LastFinalizedOutput = this.LastFinalizedOutput.bind(this);
        this.OutputProposal = this.OutputProposal.bind(this);
        this.OutputProposals = this.OutputProposals.bind(this);
        this.Params = this.Params.bind(this);
        this.Claimed = this.Claimed.bind(this);
        this.NextL1Sequence = this.NextL1Sequence.bind(this);
        this.BatchInfos = this.BatchInfos.bind(this);
    }
    Bridge(request, metadata) {
        return this.rpc.unary(exports.QueryBridgeDesc, exports.QueryBridgeRequest.fromPartial(request), metadata);
    }
    Bridges(request, metadata) {
        return this.rpc.unary(exports.QueryBridgesDesc, exports.QueryBridgesRequest.fromPartial(request), metadata);
    }
    TokenPairByL1Denom(request, metadata) {
        return this.rpc.unary(exports.QueryTokenPairByL1DenomDesc, exports.QueryTokenPairByL1DenomRequest.fromPartial(request), metadata);
    }
    TokenPairByL2Denom(request, metadata) {
        return this.rpc.unary(exports.QueryTokenPairByL2DenomDesc, exports.QueryTokenPairByL2DenomRequest.fromPartial(request), metadata);
    }
    TokenPairs(request, metadata) {
        return this.rpc.unary(exports.QueryTokenPairsDesc, exports.QueryTokenPairsRequest.fromPartial(request), metadata);
    }
    LastFinalizedOutput(request, metadata) {
        return this.rpc.unary(exports.QueryLastFinalizedOutputDesc, exports.QueryLastFinalizedOutputRequest.fromPartial(request), metadata);
    }
    OutputProposal(request, metadata) {
        return this.rpc.unary(exports.QueryOutputProposalDesc, exports.QueryOutputProposalRequest.fromPartial(request), metadata);
    }
    OutputProposals(request, metadata) {
        return this.rpc.unary(exports.QueryOutputProposalsDesc, exports.QueryOutputProposalsRequest.fromPartial(request), metadata);
    }
    Params(request, metadata) {
        return this.rpc.unary(exports.QueryParamsDesc, exports.QueryParamsRequest.fromPartial(request), metadata);
    }
    Claimed(request, metadata) {
        return this.rpc.unary(exports.QueryClaimedDesc, exports.QueryClaimedRequest.fromPartial(request), metadata);
    }
    NextL1Sequence(request, metadata) {
        return this.rpc.unary(exports.QueryNextL1SequenceDesc, exports.QueryNextL1SequenceRequest.fromPartial(request), metadata);
    }
    BatchInfos(request, metadata) {
        return this.rpc.unary(exports.QueryBatchInfosDesc, exports.QueryBatchInfosRequest.fromPartial(request), metadata);
    }
}
exports.QueryClientImpl = QueryClientImpl;
exports.QueryDesc = { serviceName: "opinit.ophost.v1.Query" };
exports.QueryBridgeDesc = {
    methodName: "Bridge",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryBridgeRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryBridgeResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryBridgesDesc = {
    methodName: "Bridges",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryBridgesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryBridgesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryTokenPairByL1DenomDesc = {
    methodName: "TokenPairByL1Denom",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryTokenPairByL1DenomRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryTokenPairByL1DenomResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryTokenPairByL2DenomDesc = {
    methodName: "TokenPairByL2Denom",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryTokenPairByL2DenomRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryTokenPairByL2DenomResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryTokenPairsDesc = {
    methodName: "TokenPairs",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryTokenPairsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryTokenPairsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryLastFinalizedOutputDesc = {
    methodName: "LastFinalizedOutput",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryLastFinalizedOutputRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryLastFinalizedOutputResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryOutputProposalDesc = {
    methodName: "OutputProposal",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryOutputProposalRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryOutputProposalResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryOutputProposalsDesc = {
    methodName: "OutputProposals",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryOutputProposalsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryOutputProposalsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryParamsDesc = {
    methodName: "Params",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryParamsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryParamsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryClaimedDesc = {
    methodName: "Claimed",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryClaimedRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryClaimedResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryNextL1SequenceDesc = {
    methodName: "NextL1Sequence",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryNextL1SequenceRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryNextL1SequenceResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
exports.QueryBatchInfosDesc = {
    methodName: "BatchInfos",
    service: exports.QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return exports.QueryBatchInfosRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = exports.QueryBatchInfosResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
class GrpcWebImpl {
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new browser_headers_1.BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc_web_1.grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc_web_1.grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
}
exports.GrpcWebImpl = GrpcWebImpl;
const gt = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (gt.Buffer) {
        return Uint8Array.from(gt.Buffer.from(b64, "base64"));
    }
    else {
        const bin = gt.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (gt.Buffer) {
        return gt.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(gt.String.fromCharCode(byte));
        });
        return gt.btoa(bin.join(""));
    }
}
function longToBigint(long) {
    return BigInt(long.toString());
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
class GrpcWebError extends gt.Error {
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}
exports.GrpcWebError = GrpcWebError;
//# sourceMappingURL=query.js.map