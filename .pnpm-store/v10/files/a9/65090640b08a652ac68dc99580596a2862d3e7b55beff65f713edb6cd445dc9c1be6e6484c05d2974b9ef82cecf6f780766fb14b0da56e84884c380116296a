import { bcs } from '@initia/initia.js';
export function bcsEncoding(arg, typeStr, target = 'base64') {
    const serializer = target === 'base64' ? 'toBase64' : 'toBytes';
    if (typeStr === 'address' || typeStr.startsWith('0x1::object::Object')) {
        return bcs
            .address()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'bool') {
        return bcs
            .bool()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u8') {
        return bcs
            .u8()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u16') {
        return bcs
            .u16()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u32') {
        return bcs
            .u32()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u64') {
        return bcs
            .u64()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u128') {
        return bcs
            .u128()
            .serialize(arg)[serializer]();
    }
    else if (typeStr === 'u256') {
        return bcs
            .u256()
            .serialize(arg)[serializer]();
    }
    else if (typeStr.startsWith('vector<u8>')) {
        return bcs
            .vector(bcs.u8())
            .serialize(arg)[serializer]();
    }
    else if (typeStr.startsWith('vector<')) {
        const innerTypeMatch = typeStr.match(/vector<([^>]+)>/);
        if (!innerTypeMatch) {
            throw new Error(`Unsupported vector type: ${typeStr}`);
        }
        const innerType = innerTypeMatch[1];
        if (innerType === 'address') {
            return bcs
                .vector(bcs.address())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'bool') {
            return bcs
                .vector(bcs.bool())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u8') {
            return bcs
                .vector(bcs.u8())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u64') {
            return bcs
                .vector(bcs.u64())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u128') {
            return bcs
                .vector(bcs.u128())
                .serialize(arg)[serializer]();
        }
        else if (innerType === 'u256') {
            return bcs
                .vector(bcs.u256())
                .serialize(arg)[serializer]();
        }
        else {
            throw new Error(`Unsupported vector inner type: ${innerType}`);
        }
    }
    else {
        throw new Error(`Unsupported type: ${typeStr}`);
    }
}
//# sourceMappingURL=bcs.js.map