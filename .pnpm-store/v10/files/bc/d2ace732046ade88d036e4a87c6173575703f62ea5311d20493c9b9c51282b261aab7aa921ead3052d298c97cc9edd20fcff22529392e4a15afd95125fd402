import { useState, useRef } from 'react';
import { useWallet as useInitiaWallet } from '@initia/react-wallet-widget';
import { MsgExecute } from '@initia/initia.js';
import { bcsEncoding } from '../utils/bcs.js';
export const useInitiaSubmitTransaction = () => {
    const { address: initiaAddress, requestInitiaTx: initiaSign } = useInitiaWallet();
    const [isIdle, setIsIdle] = useState(true);
    const [isLoading, setIsLoading] = useState(false);
    const [data, setResult] = useState();
    const [error, setError] = useState();
    const idRef = useRef(0);
    function reset() {
        setIsIdle(true);
        setIsLoading(false);
        setResult(undefined);
        setError(undefined);
        idRef.current = idRef.current + 1;
    }
    async function submitTransaction(payload) {
        const id = idRef.current;
        if (!isIdle) {
            throw new Error('Transaction is already in progress');
        }
        setIsLoading(true);
        setIsIdle(false);
        let result;
        try {
            if (initiaAddress && initiaSign) {
                if (!payload.abi) {
                    throw new Error('abi is required for initia transactions');
                }
                const [moduleAddress, moduleName, functionName] = payload.function.split('::');
                const fnAbi = payload.abi;
                const nonSignerIndex = fnAbi.parameters.findIndex((param) => {
                    return !param.toString().includes('signer');
                });
                const bcsArgs = [];
                for (let i = 0; i < payload.functionArguments.length; i++) {
                    const arg = payload.functionArguments[i];
                    const paramType = fnAbi.parameters[i + nonSignerIndex];
                    if (!paramType) {
                        throw new Error('payload and abi mismatch');
                    }
                    bcsArgs.push(bcsEncoding(arg, paramType.toString()));
                }
                result = await initiaSign({
                    msgs: [
                        new MsgExecute(initiaAddress, moduleAddress, moduleName, functionName, payload.typeArguments, bcsArgs),
                    ],
                });
            }
            else {
                throw new Error('Wallet is not connected');
            }
            if (id === idRef.current) {
                setResult(result);
                setIsLoading(false);
            }
        }
        catch (e) {
            setError(error);
            setIsLoading(false);
            throw e;
        }
        return result;
    }
    return { submitTransaction, reset, isLoading, isIdle, data, error };
};
//# sourceMappingURL=useInitiaSubmitTransaction.js.map