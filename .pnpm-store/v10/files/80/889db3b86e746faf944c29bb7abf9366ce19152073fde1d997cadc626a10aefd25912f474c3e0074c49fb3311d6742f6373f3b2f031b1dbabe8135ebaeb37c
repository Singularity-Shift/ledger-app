var $e = Object.defineProperty;
var Re = (t, e, s) => e in t ? $e(t, e, { enumerable: !0, configurable: !0, writable: !0, value: s }) : t[e] = s;
var H = (t, e, s) => Re(t, typeof e != "symbol" ? e + "" : e, s);
import { getAddress as Oe, Interface as We, ethers as je } from "ethers";
import { fromBech32 as me, toHex as k, toBech32 as Ve, fromHex as He, toBase64 as z, fromBase64 as oe } from "@cosmjs/encoding";
import y from "bignumber.js";
import { bcs as I } from "@mysten/bcs";
import { fromLittleEndian as Je, toLittleEndian as Ge, Msg as ue } from "@initia/initia.js";
import { curry as ve, pipe as Ke, groupBy as qe, prop as te, values as Ze, map as de, filter as Qe, sortWith as Xe, descend as J, path as Ye } from "ramda";
import { sha3_256 as ie } from "@noble/hashes/sha3";
import { sha256 as j } from "@noble/hashes/sha256";
import { toBytes as P, concatBytes as Me } from "@noble/hashes/utils";
import et from "long";
import { MsgSend as Te } from "cosmjs-types/cosmos/bank/v1beta1/tx";
import { MsgWithdrawDelegatorReward as tt } from "cosmjs-types/cosmos/distribution/v1beta1/tx";
import { MsgVote as st, MsgDeposit as nt, MsgSubmitProposal as rt } from "cosmjs-types/cosmos/gov/v1beta1/tx";
import { MsgTransfer as L } from "cosmjs-types/ibc/applications/transfer/v1/tx";
import { MsgBeginRedelegate as be, MsgUndelegate as xe, MsgDelegate as Be, MsgEditValidator as at, MsgCreateValidator as ot } from "@initia/initia.proto/initia/mstaking/v1/tx";
import { MsgExecute as D, MsgGovScript as it, MsgGovPublish as ct, MsgGovExecute as mt, MsgDelist as ut, MsgWhitelist as dt, MsgUpdateParams as pt, MsgScript as lt, MsgPublish as gt } from "@initia/initia.proto/initia/move/v1/tx";
import N from "ky";
import C from "zod";
import * as Se from "@msgpack/msgpack";
import { MsgTransfer as se } from "@initia/initia.proto/ibc/applications/nft_transfer/v1/tx";
import { MsgUpdateParams as ft, MsgSpendFeePool as yt, MsgRemoveValidator as ht, MsgInitiateTokenWithdrawal as wt, MsgFinalizeTokenDeposit as _t, MsgExecuteMessages as vt, MsgAddValidator as Mt } from "@initia/opinit.proto/opinit/opchild/v1/tx";
import { MsgUpdateProposer as Tt, MsgUpdateParams as bt, MsgUpdateChallenger as xt, MsgRecordBatch as Bt, MsgProposeOutput as St, MsgInitiateTokenDeposit as Pe, MsgFinalizeTokenWithdrawal as Pt, MsgDeleteOutput as Ct, MsgCreateBridge as At } from "@initia/opinit.proto/opinit/ophost/v1/tx";
import { MsgUpdateInstantiateConfig as Et, MsgClearAdmin as kt, MsgUpdateAdmin as It, MsgMigrateContract as zt, MsgExecuteContract as K, MsgInstantiateContract as Nt, MsgStoreCode as Lt } from "cosmjs-types/cosmwasm/wasm/v1/tx";
import { MsgUpdateParams as Dt, MsgCall as Ce, MsgCreate as Ut } from "@initia/initia.proto/minievm/evm/v1/tx";
import { MsgVote as Ft, MsgDeposit as $t, MsgSubmitProposal as Rt } from "@initia/initia.proto/cosmos/gov/v1/tx";
import { PubKey as Ae } from "cosmjs-types/cosmos/crypto/secp256k1/keys";
import { BaseAccount as Ot } from "cosmjs-types/cosmos/auth/v1beta1/auth";
import { encodeSecp256k1Pubkey as Wt, pubkeyType as jt, makeSignDoc as Vt } from "@cosmjs/amino";
import { decodeOptionalPubkey as Ht, Registry as Jt } from "@cosmjs/proto-signing";
import { accountFromAny as Gt, defaultRegistryTypes as Kt, AminoTypes as qt, createDefaultAminoConverters as Zt, GasPrice as X, calculateFee as Qt } from "@cosmjs/stargate";
import { Any as Xt } from "cosmjs-types/google/protobuf/any";
import { SignMode as pe } from "cosmjs-types/cosmos/tx/signing/v1beta1/signing";
import { TxBody as le, AuthInfo as ge, TxRaw as Yt } from "cosmjs-types/cosmos/tx/v1beta1/tx";
const b = {
  toBytes(t, e = 20) {
    if (!t) throw new Error("address is required");
    if (t.match(/^(0x)?[0-9a-fA-F]+$/)) {
      const n = t.replace(/^0x/, "").padStart(e * 2, "0");
      return He(n);
    }
    const { data: s } = me(t);
    return s.length >= e ? s : new Uint8Array([...Array(e - s.length).fill(0), ...s]);
  },
  toBech32(t, e = "init") {
    return t ? Ve(e, b.toBytes(t)) : "";
  },
  toHex(t) {
    return t ? k(b.toBytes(t)) : "";
  },
  toPrefixedHex(t) {
    if (!t) return "";
    const e = Oe(b.toHex(t)), s = b.toBytes(t), n = s[s.length - 1];
    return s.subarray(0, s.length - 1).every((a) => a === 0) && n < 16 ? e.replace(/^0x0+/, "0x") : e;
  },
  validate(t, e = "init") {
    if (/^0x[0-9a-fA-F]{1,40}$/.test(t))
      return !0;
    try {
      return me(t).prefix === e;
    } catch {
      return !1;
    }
  }
}, es = b.toBytes, ts = new y("4294967296"), ss = new y("18446744073709551616"), Z = new y("1000000000000000000"), ns = Z;
function G(t, e) {
  return (s) => e(s).transform({
    input: (n) => new y(n).times(t).toFixed(0, y.ROUND_DOWN),
    output: (n) => new y(n).div(t).toNumber()
  });
}
function rs(t) {
  return I.vector(I.u8(t)).transform({
    input: (e) => {
      const n = new y(e).times(Z).toFixed(0, y.ROUND_DOWN);
      return Ge(BigInt(n));
    },
    output: (e) => {
      const s = Je(e).toString();
      return new y(s).div(Z).toNumber();
    }
  });
}
function fe(t) {
  return I.bytes(32, t).transform({
    input: (e) => es(e, 32),
    output: (e) => "0x" + k(e)
  });
}
const i = {
  ...I,
  address: fe,
  object: fe,
  fixedPoint32: G(ts, I.u64),
  fixedPoint64: G(ss, I.u128),
  decimal128: G(Z, I.u128),
  decimal256: G(ns, I.u256),
  bigdecimal: rs
};
function as(t, e) {
  const n = i.address().serialize(t).toBytes(), r = i.address().serialize(e).toBytes(), a = new Uint8Array([...Me(n, r), 252]), o = ie.create().update(a).digest();
  return k(o);
}
function ne(t, e) {
  const n = i.address().serialize(t).toBytes(), r = P(e), a = new Uint8Array([...Me(n, r), 254]), o = ie.create().update(a).digest();
  return k(o);
}
function M(t) {
  return t ? t.startsWith("move/") ? "0x" + t.slice(5) : "0x" + ne("0x1", t) : "";
}
function os(t, e) {
  const s = `transfer/${t}/${e}`, n = j(s);
  return k(n);
}
function U(t, e) {
  return "ibc/" + os(t, e).toUpperCase();
}
function Ee(t) {
  return t ? Ee(t >> 8n).concat([Number(t % 256n)]) : [];
}
function is(t) {
  const e = Ee(t), s = Array(8 - e.length).fill(0);
  return new Uint8Array(s.concat(e));
}
function ke(t, e) {
  const s = new Uint8Array([...is(t), ...P(e)]), n = ie.create().update(s).digest();
  return `l2/${k(n)}`;
}
const ce = ve(({ layer: t, assets: e, layer1: s }, n) => {
  var a, o, c, m, p;
  if ((a = t.metadata) != null && a.is_l1)
    return n;
  if (n.startsWith("l2/") || n.startsWith("ibc/")) {
    const u = (o = e.find((d) => d.base === n)) == null ? void 0 : o.traces;
    if (u) {
      for (const d of u)
        if (d.counterparty.chain_name === s.chain_name)
          return d.counterparty.base_denom;
    }
  }
  const r = (p = (m = (c = s.metadata) == null ? void 0 : c.ibc_channels) == null ? void 0 : m.find(
    ({ chain_id: u, version: d }) => u === t.chain_id && d === "ics20-1"
  )) == null ? void 0 : p.channel_id;
  return r ? U(r, n) : "";
}), xn = ve(
  ({ layer: t, assets: e, layer1: s, assetsL1: n }, r) => {
    var m, p, u, d, l, g, f, h;
    if ((m = t.metadata) != null && m.is_l1)
      return r;
    if (r.startsWith("ibc/")) {
      const _ = (p = n.find((w) => w.base === r)) == null ? void 0 : p.traces;
      if (_) {
        for (const w of _)
          if (w.counterparty.chain_name === t.chain_name)
            return w.counterparty.base_denom;
      }
      for (const w of e) {
        const { traces: v } = w;
        if (v) {
          for (const T of v)
            if (T.counterparty.base_denom === r && T.counterparty.chain_name === s.chain_name)
              return w.base;
        }
      }
    }
    const a = (u = t.metadata) == null ? void 0 : u.op_bridge_id, o = (l = (d = t.metadata) == null ? void 0 : d.op_denoms) == null ? void 0 : l.includes(r), c = (h = (f = (g = t.metadata) == null ? void 0 : g.ibc_channels) == null ? void 0 : f.find(
      ({ chain_id: _, version: w }) => _ === s.chain_id && w === "ics20-1"
    )) == null ? void 0 : h.channel_id;
    return a && o ? ke(BigInt(a), r) : c ? U(c, r) : "";
  }
);
function cs(t) {
  return Object.fromEntries(t.map(({ key: e, value: s }) => [e, s]));
}
const ye = Ke(
  qe(te("metadata")),
  Ze,
  de((t = []) => {
    const { metadata: e } = t[0];
    return { amount: y.sum(...de(te("amount"), t)).toString(), metadata: e };
  }),
  Qe(({ amount: t }) => !y(t).isZero())
);
function Bn(t, e, s) {
  try {
    const r = t.filter(({ type: a }) => a === "move").map(({ attributes: a }) => cs(a)).reduce(
      (a, { type_tag: o, data: c }) => {
        try {
          const { amount: m, store_addr: p, metadata_addr: u } = JSON.parse(c);
          return "0x" + as(b.toPrefixedHex(s), u) !== p ? a : o === "0x1::fungible_asset::DepositEvent" ? [...a, { amount: y(m).toString(), metadata: u }] : o === "0x1::fungible_asset::WithdrawEvent" ? [...a, { amount: y(m).negated().toString(), metadata: u }] : a;
        } catch {
          return a;
        }
      },
      [e]
    );
    return ye(r);
  } catch {
    return ye([]);
  }
}
function ms(t) {
  if (!t) return;
  if (t.trim().startsWith("data:image/")) return t;
  const e = "https://img.initia.xyz/?url=";
  return e + t.replace(e, "");
}
function Sn({ typeUrl: t, value: e }) {
  var s;
  switch (t) {
    /* cosmos: bank */
    case "/cosmos.bank.v1beta1.MsgSend":
      return ["Send", Te.fromPartial(e).toAddress];
    /* cosmos: distribution */
    case "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward":
      return ["Withdraw rewards", tt.fromPartial(e).validatorAddress];
    /* cosmos: gov */
    case "/cosmos.gov.v1beta1.MsgSubmitProposal":
      return ["Submit proposal", ((s = rt.fromPartial(e).content) == null ? void 0 : s.typeUrl.split(".").at(-1)) ?? ""];
    case "/cosmos.gov.v1beta1.MsgDeposit":
      return ["Deposit", nt.fromPartial(e).proposalId.toString()];
    case "/cosmos.gov.v1beta1.MsgVote":
      return ["Vote", st.fromPartial(e).proposalId.toString()];
    /* cosmos:ibc */
    case "/ibc.core.client.v1.MsgUpdateClient":
      return ["Update client", ""];
    case "/ibc.core.channel.v1.MsgRecvPacket":
      return ["Recieve packet", ""];
    case "/ibc.applications.transfer.v1.MsgTransfer":
      return ["Send", L.fromPartial(e).receiver];
    /* initia */
    case "/initia.mstaking.v1.MsgDelegate":
      return ["Stake", Be.fromPartial(e).validatorAddress];
    case "/initia.mstaking.v1.MsgUndelegate":
      return ["Unstake", xe.fromPartial(e).validatorAddress];
    case "/initia.mstaking.v1.MsgBeginRedelegate":
      return ["Move stake", be.fromPartial(e).validatorDstAddress];
    /* initia:move */
    case "/initia.move.v1.MsgExecute":
      return [
        `Execute ${D.fromPartial(e).functionName ?? ""}`,
        D.fromPartial(e).moduleAddress
      ];
    default:
      return [t.split("Msg")[1], ""];
  }
}
function Pn({ type: t, value: e }) {
  var s;
  switch (t) {
    /* cosmos: bank */
    case "cosmos-sdk/MsgSend":
      return ["Send", e.to_address];
    /* cosmos: distribution */
    case "cosmos-sdk/MsgWithdrawDelegationReward":
      return ["Withdraw rewards", e.validator_address];
    /* cosmos: gov */
    case "cosmos-sdk/v1/MsgSubmitProposal":
      return ["Submit proposal", ((s = e.messages[0]) == null ? void 0 : s.type.split("/").at(-1)) ?? ""];
    case "cosmos-sdk/v1/MsgDeposit":
      return ["Deposit", e.proposal_id];
    case "cosmos-sdk/v1/MsgVote":
      return ["Vote", e.proposal_id];
    /* cosmos:ibc */
    case "cosmos-sdk/MsgTransfer":
      return ["Send", e.receiver];
    /* initia */
    case "mstaking/MsgDelegate":
      return ["Stake", e.validator_address];
    case "mstaking/MsgUndelegate":
      return ["Unstake", e.validator_address];
    case "mstaking/MsgBeginRedelegate":
      return ["Move stake", e.validator_dst_address];
    /* initia:move */
    case "move/MsgExecute":
      return [`Execute ${e.function_name ?? ""}`, e.module_address];
    default:
      return [t.split("Msg")[1], ""];
  }
}
function us(t) {
  return et.isLong(t) ? t.toString() : t instanceof Uint8Array ? z(t) : Array.isArray(t) && t.some((e) => e instanceof Uint8Array) ? JSON.stringify(t.map((e) => us(e))) : t !== null && typeof t == "object" ? JSON.stringify(t) : String(t);
}
function Cn(t, e) {
  const s = e.filter((n) => !n.startsWith("&"));
  return t.map((n, r) => {
    try {
      return {
        type: s[r],
        encoded: n,
        decoded: re(s[r]).parse(oe(n))
      };
    } catch {
      return { type: s[r], encoded: n, decoded: "" };
    }
  });
}
function re(t) {
  const [e, ...s] = t.split("<"), n = [e.split("::").at(-1), ...s].join("<").toLocaleLowerCase();
  if (n.startsWith("option"))
    return i.option(re(t.replace("option<", "").slice(0, -1)));
  if (n.startsWith("vector"))
    return i.vector(re(t.replace("vector<", "").slice(0, -1)));
  if (n.startsWith("object"))
    return i.object();
  switch (n) {
    case "address":
      return i.address();
    case "string":
      return i.string();
    case "decimal128":
      return i.decimal128();
    case "decimal256":
      return i.decimal256();
    case "u8":
      return i.u8();
    case "u16":
      return i.u16();
    case "u32":
      return i.u32();
    case "u64":
      return i.u64();
    case "u128":
      return i.u128();
    case "u256":
      return i.u256();
    case "bool":
      return i.bool();
    case "fixedPoint32":
      return i.fixedPoint32();
    case "fixedPoint64":
      return i.fixedPoint64();
  }
}
function ds(t) {
  return t.pagination.next_key;
}
async function ps(t, e, s) {
  const n = N.create(e), r = async (a, o) => {
    const c = await n.extend(o ? { searchParams: { "pagination.key": o } } : {}).get(t).json(), m = c[s] ?? [], p = ds(c), u = [...a, ...m];
    return p ? r(u, p) : u;
  };
  return r([], null);
}
function An(t, e) {
  var r, a, o, c;
  const s = ((r = e == null ? void 0 : e.pages) == null ? void 0 : r.map((m) => m[t] ?? []).flat()) ?? [], n = Number((c = (o = (a = e == null ? void 0 : e.pages) == null ? void 0 : a[0]) == null ? void 0 : o.pagination) == null ? void 0 : c.total) || 0;
  return { list: s, count: n };
}
function F(t) {
  const e = N.create({ prefixUrl: t }), s = "initia/move/v1";
  async function n() {
    const u = `${s}/params`, { params: d } = await e.get(u).json();
    return d;
  }
  async function r(u) {
    const d = `${s}/denom`, { denom: l } = await e.get(d, { searchParams: { metadata: u } }).json();
    return l;
  }
  async function a(u) {
    const d = `${s}/metadata`, { metadata: l } = await e.get(d, { searchParams: { denom: u } }).json();
    return l;
  }
  async function o(u, d) {
    const l = `${s}/accounts/${u}/resources/by_struct_tag`, { resource: g } = await e.get(l, { searchParams: { struct_tag: d } }).json();
    return JSON.parse(g.move_resource).data;
  }
  async function c(u) {
    const d = `${s}/accounts/${u}/resources`;
    return (await ps(d, { prefixUrl: t }, "resources")).map(({ move_resource: g }) => JSON.parse(g));
  }
  async function m({ moduleAddress: u, moduleName: d }) {
    const l = `initia/move/v1/accounts/${u}/modules/${d}`, { module: g } = await e.get(l).json();
    return g;
  }
  async function p({ moduleAddress: u, moduleName: d, functionName: l, typeArgs: g, args: f }) {
    const h = `initia/move/v1/accounts/${u}/modules/${d}/view_functions/${l}`, _ = { type_args: g, args: f }, { data: w, message: v } = await e.post(h, { json: _ }).json();
    if (v) throw new Error(v);
    return JSON.parse(w);
  }
  return {
    rest: t,
    params: n,
    denom: r,
    metadata: a,
    resource: o,
    resources: c,
    modules: m,
    view: p
  };
}
const Ie = [
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "address", name: "owner", type: "address" }
    ],
    name: "ERC721IncorrectOwner",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "ERC721InsufficientApproval",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "approver", type: "address" }],
    name: "ERC721InvalidApprover",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "operator", type: "address" }],
    name: "ERC721InvalidOperator",
    type: "error"
  },
  { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "ERC721InvalidOwner", type: "error" },
  {
    inputs: [{ internalType: "address", name: "receiver", type: "address" }],
    name: "ERC721InvalidReceiver",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "ERC721InvalidSender",
    type: "error"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "ERC721NonexistentToken",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "approved", type: "address" },
      { indexed: !0, internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "owner", type: "address" },
      { indexed: !0, internalType: "address", name: "operator", type: "address" },
      { indexed: !1, internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      { indexed: !0, internalType: "address", name: "from", type: "address" },
      { indexed: !0, internalType: "address", name: "to", type: "address" },
      { indexed: !0, internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "getApproved",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "operator", type: "address" }
    ],
    name: "isApprovedForAll",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "ownerOf",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "tokenId", type: "uint256" }],
    name: "tokenURI",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], he = new We(Ie);
function ls(t) {
  const e = N.create({ prefixUrl: t });
  async function s({
    sender: n = b.toBech32("0x1"),
    contractAddress: r,
    fragment: a,
    values: o,
    withTrace: c = !1
  }) {
    const m = "minievm/evm/v1/call", p = {
      sender: n,
      contract_addr: b.toPrefixedHex(r),
      input: he.encodeFunctionData(a, o),
      with_trace: c
    }, { response: u } = await e.post(m, { json: p }).json(), [d] = he.decodeFunctionResult(a, u);
    return d;
  }
  return {
    rest: t,
    call: s
  };
}
function gs(t) {
  const e = F(t), s = "0x1", n = "dex";
  async function r(o) {
    return e.view({
      moduleAddress: s,
      moduleName: n,
      functionName: "get_config",
      typeArgs: [],
      args: [i.address().serialize(o).toBase64()]
    });
  }
  async function a(o, c) {
    return e.view({
      moduleAddress: s,
      moduleName: n,
      functionName: "get_spot_price",
      typeArgs: [],
      args: [i.address().serialize(c).toBase64(), i.address().serialize(o).toBase64()]
    });
  }
  return {
    rest: t,
    getConfig: r,
    getSpotPrice: a
  };
}
function we(t) {
  const e = F(t), s = "0x1", n = "stableswap";
  async function r(o) {
    return e.view({
      moduleAddress: s,
      moduleName: n,
      functionName: "get_pool",
      typeArgs: [],
      args: [i.address().serialize(o).toBase64()]
    });
  }
  function a(o, c, m) {
    return async function(p) {
      return e.view({
        moduleAddress: s,
        moduleName: n,
        functionName: "get_swap_simulation",
        typeArgs: [],
        args: [
          i.address().serialize(m).toBase64(),
          i.address().serialize(o).toBase64(),
          i.address().serialize(c).toBase64(),
          i.u64().serialize(p).toBase64()
        ]
      });
    };
  }
  return {
    rest: t,
    getPool: r,
    getSwapSimulation: a
  };
}
function fs(t, e, s) {
  const n = F(t), r = ls(t), a = N.create({ prefixUrl: t }), o = "0x1", c = "nft";
  async function m() {
    switch (s) {
      case "minimove":
        return n.resource(e, "0x1::collection::Collection");
      case "minievm":
        return { name: await r.call({ contractAddress: e, fragment: "name" }) };
      default:
        throw new Error("Not supported NFT");
    }
  }
  async function p(u) {
    switch (s) {
      case "minimove":
        return n.view({
          moduleAddress: o,
          moduleName: c,
          functionName: "nft_info",
          typeArgs: [],
          args: [i.address().serialize(u).toBase64()]
        });
      case "miniwasm": {
        const d = z(P(JSON.stringify({ nft_info: { token_id: u } }))), l = `cosmwasm/wasm/v1/contract/${e}/smart/${d}`, { data: g } = await a.get(l).json();
        return { token_id: u, uri: g.token_uri };
      }
      case "minievm": {
        const d = await r.call({
          contractAddress: e,
          fragment: "tokenURI",
          values: [u]
        });
        return { token_id: u, uri: d };
      }
      default:
        throw new Error("Not supported NFT");
    }
  }
  return {
    rest: t,
    getCollectionInfo: m,
    getTokenInfo: p
  };
}
function ys(t, e) {
  const s = F(t), n = "dex_utils";
  function r(o, c) {
    return async function(m) {
      return s.view({
        moduleAddress: e,
        moduleName: n,
        functionName: "get_swap_simulation",
        typeArgs: [],
        args: [
          i.address().serialize(c).toBase64(),
          i.address().serialize(o).toBase64(),
          i.u64().serialize(m).toBase64()
        ]
      });
    };
  }
  function a(o, c) {
    return async function(m) {
      return s.view({
        moduleAddress: e,
        moduleName: n,
        functionName: "get_route_swap_simulation",
        typeArgs: [],
        args: [
          i.address().serialize(o).toBase64(),
          i.vector(i.address()).serialize(c).toBase64(),
          i.u64().serialize(m).toBase64()
        ]
      });
    };
  }
  return {
    rest: t,
    getSwapSimulation: r,
    getRouteSwapSimulation: a
  };
}
function hs(t = "") {
  if (!t.endsWith(".init")) return !1;
  const e = t.slice(0, -5);
  return e.length > 64 ? !1 : /^[A-Za-z0-9-]+$/.test(e);
}
function En(t, e) {
  const s = F(t), n = "usernames";
  async function r(o) {
    if (!b.validate(o)) return null;
    const c = i.address().serialize(o).toBase64(), m = await s.view({
      moduleAddress: e,
      moduleName: n,
      functionName: "get_name_from_address",
      typeArgs: [],
      args: [c]
    });
    return m ? m + ".init" : null;
  }
  async function a(o) {
    if (!hs(o)) return null;
    const c = i.string().serialize(o.toLowerCase().replace(".init", "")).toBase64(), m = await s.view({
      moduleAddress: e,
      moduleName: n,
      functionName: "get_address_from_name",
      typeArgs: [],
      args: [c]
    });
    return m ? b.toBech32(m) : null;
  }
  return {
    rest: t,
    getUsername: r,
    getAddress: a
  };
}
function _e(t) {
  return {
    denom: t.base,
    metadata: M(t.base),
    address: t.address,
    decimals: _s(t),
    name: t.name,
    description: t.description,
    symbol: t.symbol,
    image: ws(t),
    coingeckoId: t.coingecko_id
  };
}
async function kn(t, e) {
  var p, u;
  const { layer: s, layer1: n, assets: r, assetsL1: a } = e, o = r.find((d) => d.base === t);
  if (o) return _e(o);
  const c = ce({ layer1: n, layer: s, assets: r }, t);
  if (c) {
    const d = a.find((l) => l.base === c);
    if (d) return { ..._e(d), denom: t, metadata: M(t) };
  }
  const m = M(t);
  if (((u = (p = s.metadata) == null ? void 0 : p.minitia) == null ? void 0 : u.type) !== "miniwasm")
    try {
      const l = await F(A(s)).resource(m, "0x1::fungible_asset::Metadata"), { name: g, symbol: f, decimals: h } = l;
      return { denom: t, metadata: m, name: g, symbol: f, decimals: h };
    } catch {
      return { denom: t, metadata: m, decimals: 0, symbol: t };
    }
  return { denom: t, metadata: m, decimals: 0, symbol: t };
}
function In(t, { layer: e, assets: s, layer1: n, prices: r = {} }) {
  const a = ce({ layer1: n, layer: e, assets: s }), o = (p) => {
    var u;
    return !!((u = e.fees) != null && u.fee_tokens.some((d) => d.denom === p));
  }, c = (p) => {
    const u = a(p.denom), d = r[u ?? p.denom] ?? 0, l = parseFloat(p.amount);
    return d * l;
  }, m = (p) => s.some((u) => u.base === p);
  return Xe(
    [
      J((p) => a(p.denom) === "uinit"),
      J((p) => o(p.denom)),
      J((p) => c(p)),
      J((p) => m(p.denom))
    ],
    t
  );
}
function ze(t) {
  if (!new RegExp("^https?:").test(t)) throw new Error(`Invalid URL: ${t}`);
  return t;
}
function zn(t) {
  return t.pretty_name ?? t.chain_name;
}
function Nn(t) {
  var s, n, r;
  const e = (r = (n = (s = t.apis) == null ? void 0 : s.rpc) == null ? void 0 : n[0]) == null ? void 0 : r.address;
  if (!e) throw new Error(`RPC not found for ${t.chain_id}`);
  return ze(e);
}
function A(t) {
  var s, n, r;
  const e = (r = (n = (s = t.apis) == null ? void 0 : s.rest) == null ? void 0 : n[0]) == null ? void 0 : r.address;
  if (!e) throw new Error(`REST not found for ${t.chain_id}`);
  return ze(e);
}
function ws(t) {
  var e;
  return ms((e = t.logo_URIs) == null ? void 0 : e.png);
}
function _s(t) {
  var s, n, r;
  return ((s = t.denom_units.find((a) => a.denom === t.display)) == null ? void 0 : s.exponent) ?? ((n = t.denom_units.find((a) => a.denom === t.base)) == null ? void 0 : n.exponent) ?? ((r = t.denom_units[0]) == null ? void 0 : r.exponent) ?? 0;
}
function Ne(t, e, s) {
  var a;
  const n = (a = t.metadata) == null ? void 0 : a.ibc_channels, r = { transfer: "ics20-1", "nft-transfer": "ics721-1" }[s];
  return n == null ? void 0 : n.find(
    ({ chain_id: o, version: c }) => o === e.chain_id && c.includes(r)
  );
}
function S(t, e) {
  var s;
  return (s = Ne(t, e, "transfer")) == null ? void 0 : s.channel_id;
}
function W(t, e) {
  return Ne(t, e, "nft-transfer");
}
const vs = C.object({
  typeUrl: C.string(),
  value: C.record(C.any())
}), Ln = C.object({
  messages: C.array(vs),
  memo: C.string().optional()
}), Dn = C.object({
  amount: C.string(),
  denom: C.string()
});
class Un extends Error {
  constructor(s) {
    super("Pending transaction. Check your transaction in the explorer.");
    H(this, "transactionHash");
    this.name = "TimeoutError", this.transactionHash = s;
  }
}
var Ms = /* @__PURE__ */ ((t) => (t.Keplr = "Keplr", t.Leap = "Leap Wallet", t))(Ms || {});
function Fn(t = "") {
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const Le = ["K", "M", "B", "T"];
function Ts(t) {
  const e = (s, n) => s.gte(1e3) && n < Le.length - 1 ? e(s.div(1e3), n + 1) : [s, n - 1];
  return e(y(t), 0);
}
function bs(t, e = {}) {
  const s = y(t);
  if (s.isZero() || s.isNaN()) return "0";
  const { dp: n = 2, unitConversion: r = !1 } = e, [a, o] = r ? Ts(s) : [s, -1], c = new Intl.NumberFormat("en-US", {
    minimumFractionDigits: n,
    maximumFractionDigits: n
  }).format(a.decimalPlaces(n, y.ROUND_DOWN).toNumber());
  return o !== -1 ? `${c}${Le[o]}` : c;
}
function $n(t, e = {}) {
  if (!t) return "0";
  const s = y(t);
  if (s.isZero() || s.isNaN()) return "0";
  const { decimals: n = 6, dp: r = 6, unitConversion: a } = e, o = s.div(new y(10).pow(n));
  return bs(o, { dp: r ?? (a ? void 0 : n), unitConversion: a });
}
function xs(t, e = 6) {
  return !t || y(t).isNaN() ? "0" : new y(t).times(new y(10).pow(e)).integerValue().toString(10);
}
function Bs(t, e = 6) {
  return !t || y(t).isNaN() ? "0" : new y(t).integerValue().div(new y(10).pow(e)).toString();
}
function Rn(t, e) {
  if (!t || y(t).isNaN()) return "0%";
  const s = new y(t).times(100);
  return typeof e == "number" ? s.toFixed(e) + "%" : (s.gte(100) ? s.toFixed(0) : s.toFixed(2)) + "%";
}
function Q(t, e) {
  return typeof t != "object" || t === null ? t : Array.isArray(t) ? t.map((s) => Q(s, e)) : Object.fromEntries(
    Object.entries(t).map(([s, n]) => [e(s), Q(n, e)])
  );
}
function Ss(t) {
  return t.replace(/_([a-z])/g, (e, s) => s.toUpperCase());
}
function Ps(t) {
  return t.replace(/[A-Z]/g, (e) => `_${e.toLowerCase()}`);
}
function On(t) {
  return Q(t, Ss);
}
function Wn(t) {
  return Q(t, Ps);
}
function jn(t) {
  return z(Se.encode(t, { useBigInt64: !0, ignoreUndefined: !0 }));
}
function Vn(t) {
  return Se.decode(oe(t), { useBigInt64: !0 });
}
function Hn(t = "", [e, s] = [6, 6]) {
  const n = t.slice(0, e), r = t.slice(-1 * s, t.length);
  return t.length > e + s ? [n, r].join("...") : t;
}
class ae {
  static getItem(e) {
    try {
      const s = localStorage.getItem(e);
      return s ? JSON.parse(s) : null;
    } catch {
      return null;
    }
  }
  static setItem(e, s) {
    try {
      const n = JSON.stringify(s);
      localStorage.setItem(e, n);
    } catch {
    }
  }
  static removeItem(e) {
    try {
      localStorage.removeItem(e);
    } catch {
    }
  }
}
const De = {
  /* move */
  "/initia.move.v1.MsgExecute": { msg: D, aminoType: "move/MsgExecute" },
  "/initia.move.v1.MsgPublish": { msg: gt, aminoType: "move/MsgPublish" },
  "/initia.move.v1.MsgScript": { msg: lt, aminoType: "move/MsgScript" },
  "/initia.move.v1.MsgUpdateParams": { msg: pt, aminoType: "move/MsgUpdateParams" },
  "/initia.move.v1.MsgWhitelist": { msg: dt, aminoType: "move/MsgWhitelist" },
  "/initia.move.v1.MsgDelist": { msg: ut, aminoType: "move/MsgDelist" },
  "/initia.move.v1.MsgGovExecute": { msg: mt, aminoType: "move/MsgGovExecute" },
  "/initia.move.v1.MsgGovPublish": { msg: ct, aminoType: "move/MsgGovPublish" },
  "/initia.move.v1.MsgGovScript": { msg: it, aminoType: "move/MsgGovScript" },
  /* wasm */
  "/cosmwasm.wasm.v1.MsgStoreCode": { msg: Lt, aminoType: "wasm/MsgStoreCode" },
  "/cosmwasm.wasm.v1.MsgInstantiateContract": { msg: Nt, aminoType: "wasm/MsgInstantiateContract" },
  "/cosmwasm.wasm.v1.MsgExecuteContract": { msg: K, aminoType: "wasm/MsgExecuteContract" },
  "/cosmwasm.wasm.v1.MsgMigrateContract": { msg: zt, aminoType: "wasm/MsgMigrateContract" },
  "/cosmwasm.wasm.v1.MsgUpdateAdmin": { msg: It, aminoType: "wasm/MsgUpdateAdmin" },
  "/cosmwasm.wasm.v1.MsgClearAdmin": { msg: kt, aminoType: "wasm/MsgClearAdmin" },
  "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig": { msg: Et, aminoType: "wasm/MsgUpdateInstantiateConfig" },
  /* evm */
  "/minievm.evm.v1.MsgCreate": { msg: Ut, aminoType: "evm/MsgCreate" },
  "/minievm.evm.v1.MsgCall": { msg: Ce, aminoType: "evm/MsgCall" },
  "/minievm.evm.v1.MsgUpdateParams": { msg: Dt, aminoType: "evm/MsgUpdateParams" },
  /* mstaking */
  "/initia.mstaking.v1.MsgDelegate": { msg: Be, aminoType: "mstaking/MsgDelegate" },
  "/initia.mstaking.v1.MsgUndelegate": { msg: xe, aminoType: "mstaking/MsgUndelegate" },
  "/initia.mstaking.v1.MsgBeginRedelegate": { msg: be, aminoType: "mstaking/MsgBeginRedelegate" },
  "/initia.mstaking.v1.MsgCreateValidator": { msg: ot, aminoType: "mstaking/MsgCreateValidator" },
  "/initia.mstaking.v1.MsgEditValidator": { msg: at, aminoType: "mstaking/MsgEditValidator" },
  /* ibc */
  "/ibc.applications.nft_transfer.v1.MsgTransfer": { msg: se, aminoType: "nft-transfer/MsgTransfer" },
  /* op */
  "/opinit.opchild.v1.MsgAddValidator": { msg: Mt, aminoType: "opchild/MsgAddValidator" },
  "/opinit.opchild.v1.MsgExecuteMessages": { msg: vt, aminoType: "opchild/MsgExecuteMessages" },
  "/opinit.opchild.v1.MsgFinalizeTokenDeposit": { msg: _t, aminoType: "opchild/MsgFinalizeTokenDeposit" },
  "/opinit.opchild.v1.MsgInitiateTokenWithdrawal": { msg: wt, aminoType: "opchild/MsgInitiateTokenWithdrawal" },
  "/opinit.opchild.v1.MsgRemoveValidator": { msg: ht, aminoType: "opchild/MsgRemoveValidator" },
  "/opinit.opchild.v1.MsgSpendFeePool": { msg: yt, aminoType: "opchild/MsgSpendFeePool" },
  "/opinit.opchild.v1.MsgUpdateParams": { msg: ft, aminoType: "opchild/MsgUpdateParams" },
  "/opinit.ophost.v1.MsgCreateBridge": { msg: At, aminoType: "ophost/MsgCreateBridge" },
  "/opinit.ophost.v1.MsgDeleteOutput": { msg: Ct, aminoType: "ophost/MsgDeleteOutput" },
  "/opinit.ophost.v1.MsgFinalizeTokenWithdrawal": { msg: Pt, aminoType: "ophost/MsgFinalizeTokenWithdrawal" },
  "/opinit.ophost.v1.MsgInitiateTokenDeposit": { msg: Pe, aminoType: "ophost/MsgInitiateTokenDeposit" },
  "/opinit.ophost.v1.MsgProposeOutput": { msg: St, aminoType: "ophost/MsgProposeOutput" },
  "/opinit.ophost.v1.MsgRecordBatch": { msg: Bt, aminoType: "ophost/MsgRecordBatch" },
  "/opinit.ophost.v1.MsgUpdateChallenger": { msg: xt, aminoType: "ophost/MsgUpdateChallenger" },
  "/opinit.ophost.v1.MsgUpdateParams": { msg: bt, aminoType: "ophost/MsgUpdateParams" },
  "/opinit.ophost.v1.MsgUpdateProposer": { msg: Tt, aminoType: "ophost/MsgUpdateProposer" },
  /* gov */
  "/cosmos.gov.v1.MsgSubmitProposal": { msg: Rt, aminoType: "cosmos-sdk/v1/MsgSubmitProposal" },
  "/cosmos.gov.v1.MsgDeposit": { msg: $t, aminoType: "cosmos-sdk/v1/MsgDeposit" },
  "/cosmos.gov.v1.MsgVote": { msg: Ft, aminoType: "cosmos-sdk/v1/MsgVote" }
};
function Cs(t) {
  if ((t == null ? void 0 : t.typeUrl) === "/initia.crypto.v1beta1.ethsecp256k1.PubKey") {
    const { key: e } = Ae.decode(t.value);
    return Wt(e);
  }
  return Ht(t);
}
function Jn({ typeUrl: t, value: e }) {
  if (t === "/cosmos.auth.v1beta1.BaseAccount") {
    const { address: s, pubKey: n, accountNumber: r, sequence: a } = Ot.decode(e), o = Cs(n);
    return { address: s, pubkey: o, accountNumber: Number(r), sequence: Number(a) };
  }
  return Gt({ typeUrl: t, value: e });
}
const As = {
  ...jt,
  /** https://github.com/initia-labs/initia/blob/main/crypto/ethsecp256k1/ethsecp256k1.go#L40 */
  ethsecp256k1: "initia/PubKeyEthSecp256k1"
};
function Es(t) {
  if (t.length !== 33 || t[0] !== 2 && t[0] !== 3)
    throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
  return {
    type: As.ethsecp256k1,
    value: z(t)
  };
}
function Gn(t, e) {
  if (e.length !== 64)
    throw new Error(
      "Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s."
    );
  return {
    pub_key: Es(t),
    signature: z(e)
  };
}
const ks = Object.entries(De).filter(([, { msg: t }]) => t).map(([t, { msg: e }]) => [t, e]), Is = [...Kt, ...ks];
function zs(t = []) {
  return new Jt([...Is, ...t]);
}
function Ns() {
  const t = zs();
  return Object.fromEntries(
    Object.entries(De).filter(([, { aminoType: e }]) => e).map(([e, { aminoType: s }]) => [e, {
      aminoType: s,
      toAmino: (r) => ue.fromProto(t.encodeAsAny({ typeUrl: e, value: r })).toAmino().value,
      fromAmino: (r) => ue.fromAmino({ type: s, value: r }).toProto()
    }])
  );
}
function Kn(t = {}) {
  return new qt({ ...Zt(), ...Ns(), ...t });
}
function qn(t, e, s, n) {
  return async function(r, a, o, c) {
    const m = a.map(($) => n.toAmino($)), [{ pubkey: p }] = await e.getAccounts(), u = await s.getAccount(r);
    if (!u) throw new Error("Account not found");
    const { accountNumber: d, sequence: l } = u, g = Vt(m, o, t, c, d, l), { signature: f } = await e.signAmino(r, g), h = le.fromPartial({
      messages: a.map(($) => s.registry.encodeAsAny($)),
      memo: c
    }), _ = f.pub_key.type === "initia/PubKeyEthSecp256k1", w = _ ? "/initia.crypto.v1beta1.ethsecp256k1.PubKey" : "/cosmos.crypto.secp256k1.PubKey", v = _ ? pe.SIGN_MODE_EIP_191 : pe.SIGN_MODE_LEGACY_AMINO_JSON, T = Xt.fromPartial({
      typeUrl: w,
      value: Uint8Array.from(Ae.encode({ key: p }).finish())
    }), x = ge.fromPartial({
      signerInfos: [
        {
          publicKey: T,
          modeInfo: { single: { mode: v } },
          sequence: BigInt(l)
        }
      ],
      fee: {
        amount: [...o.amount],
        gasLimit: BigInt(o.gas),
        granter: o.granter,
        payer: o.payer
      }
    });
    return Yt.fromPartial({
      bodyBytes: le.encode(h).finish(),
      authInfoBytes: ge.encode(x).finish(),
      signatures: [oe(f.signature)]
    });
  };
}
class Y extends Error {
  constructor(s, n) {
    super(Ls(s, n));
    H(this, "originalMessage");
    this.name = "FriendlyError", this.originalMessage = s;
  }
}
const Ue = (t) => {
  const s = /VM aborted: location=([0-9A-Fa-f]+)::(\w+), code=(\d+)/.exec(t);
  if (!s) return null;
  const [, n, r, a] = s, o = "0x" + (n.replace(/^0+/, "") || "0"), c = a.replace(/^0+/, "") || "0";
  return { moduleAddress: o, moduleName: r, errorCode: c };
}, Ls = (t, e) => {
  var s;
  if (Array.isArray(e)) {
    const n = e.find(({ pattern: r }) => new RegExp(r).test(t));
    if (n) {
      const { pattern: r, replacer: a } = n, c = new RegExp(r).exec(t);
      if (c)
        return a.replace(/\$(\d+)/g, (m, p) => c[Number(p)]);
    }
  } else {
    const n = Ue(t);
    if (n) {
      const { moduleAddress: r, moduleName: a, errorCode: o } = n, c = (s = e[a]) == null ? void 0 : s[o];
      return c || `Failed with code ${"0x" + parseInt(o, 10).toString(16)} in module ${a} at ${r}`;
    }
  }
  return t;
};
async function Zn(t, { prefixUrl: e, chainId: s }) {
  if (!(t instanceof Error)) return new Error(String(t));
  const n = N.create({ prefixUrl: e });
  try {
    const r = Ue(t.message);
    if (!r) {
      const m = await n.get("cosmos.json").json();
      return new Y(t.message, m);
    }
    const { moduleAddress: a } = r, o = a === "0x1" ? "0x1.json" : `${s}/${a}.json`, c = await n.get(o).json();
    return new Y(t.message, c);
  } catch {
    return new Y(t.message, {});
  }
}
function Ds(t, e, s) {
  var a, o;
  if (!t) return null;
  const n = (o = (a = e.fees) == null ? void 0 : a.fee_tokens.find(({ denom: c }) => c === t)) == null ? void 0 : o.fixed_min_gas_price;
  if (typeof n == "number")
    return X.fromString(n + t);
  const r = Number(Ye([t], s));
  return Number.isFinite(r) ? X.fromString(r + t) : X.fromString(0 + t);
}
function Qn(t, e = [], s) {
  var a;
  const n = (a = t.fees) == null ? void 0 : a.fee_tokens;
  if (!n) throw new Error("No fee tokens found");
  const r = ae.getItem(s);
  if (r) {
    const o = r[t.chain_id];
    if (o && n.some(({ denom: c }) => c === o))
      return o;
  }
  for (const { amount: o, denom: c } of e)
    if (y(o).gt(0) && n.some((m) => m.denom === c))
      return c;
  return n.length > 0 ? n[0].denom : "";
}
function Xn(t) {
  var w, v;
  const { layer: e, feeDenom: s, feeAmount: n, balances: r, gas: a, gasAdjustment: o, gasPrices: c, storageKey: m } = t, p = Ds(s, e, c), u = Math.ceil(a * o), d = p ? n ? { amount: [{ amount: n, denom: s }], gas: u.toString() } : Qt(u, p) : { amount: [], gas: u.toString() }, l = ((w = d.amount[0]) == null ? void 0 : w.amount) ?? "0", g = ((v = r == null ? void 0 : r.find(({ denom: T }) => T === s)) == null ? void 0 : v.amount) ?? "0", f = r ? y(g).gte(l) : void 0;
  return { stdFee: d, fee: { amount: l, denom: s }, hasSufficientBalance: f, insufficientBalanceWarning: typeof f == "boolean" && !f ? "Insufficient balance to pay fees." : void 0, onApprove: () => {
    const T = ae.getItem(m);
    ae.setItem(m, { ...T, [e.chain_id]: s });
  } };
}
function Yn({ balance: t = "0", decimals: e = 6 }) {
  return {
    insufficient: () => {
      if (y(t).isZero()) return "Insufficient balance";
    },
    decimal: (s) => {
      const [, n] = s.split(".");
      if ((n == null ? void 0 : n.length) > e) return `Amount must be within ${e} decimal points`;
    },
    range: (s) => {
      const n = xs(s, e);
      if (!(y(n).gt(0) && y(n).lte(t))) return `Amount must be between 0 and ${Bs(t, e)}`;
    }
  };
}
function Us(t) {
  return y(t).isNaN() ? { type: "error", message: "Slippage must be greater than 0" } : y(t).lt(0) ? { type: "error", message: "Slippage must be greater than 0" } : y(t).gt(50) ? { type: "error", message: "Slippage must be less than 50" } : y(t).lt(0.5) ? { type: "warning", message: "Transaction may fail" } : y(t).gt(1) ? { type: "warning", message: "Transaction may be frontrun" } : { type: "success", message: "" };
}
function E(t) {
  return JSON.stringify({ move: { message: t } });
}
function B(t) {
  return BigInt(
    y(Date.now()).plus(t * 60 * 1e3).times(1e6).toString()
  );
}
function ee(t, e) {
  const s = Us(e).type === "error" ? Fe : e;
  return y(t).times(y(100).minus(s)).div(100).toFixed(0);
}
function q({ layer: t, layer1: e }) {
  if (e.chain_id === t.chain_id) return;
  const s = S(e, t), n = S(t, e);
  if (s && n)
    return { fromL1ToL2: s, fromL2ToL1: n };
}
function er({
  layer: t,
  layer1: e,
  swappableL1: s
}) {
  var r;
  if ((r = t.metadata) != null && r.is_l1)
    return s;
  const n = q({ layer: t, layer1: e });
  return n ? s.map((a) => {
    var o, c, m;
    if (!((c = (o = t.metadata) == null ? void 0 : o.op_denoms) != null && c.includes(a))) return U(n.fromL2ToL1, a);
    if (!((m = t.metadata) != null && m.op_bridge_id)) throw new Error("op_bridge_id not found");
    return ke(BigInt(t.metadata.op_bridge_id), a);
  }) : [];
}
const Fe = 0.5, tr = Fe / 100;
class Fs {
  constructor(e, s) {
    this.tx = e, this.sendParams = s;
  }
  isMsgTransfer(e) {
    return e.receiver !== void 0;
  }
  getSimulationParams({ amount: e }) {
    try {
      const [{ value: s }] = this.getMessages({ amount: e, recipientAddress: this.tx.params.address });
      if (!this.isMsgTransfer(s)) return null;
      const { receiver: n } = s, { layer1: r, modules: a } = this.tx.params;
      return n.startsWith(`${a.swap_transfer}::swap_transfer::minit_swap_to`) ? this.sendParams : n.startsWith(`${a.swap_transfer}::swap_transfer::minit_swap_deposit`) ? { ...this.sendParams, targetLayer: r } : null;
    } catch {
      return null;
    }
  }
  async simulate({ amount: e }) {
    const s = this.getSimulationParams({ amount: e });
    if (!s) return null;
    const { layer: n, layer1: r } = this.tx.params, { denom: a, targetLayer: o } = s, c = F(A(r));
    if (!y(e).gt(0) || !(n && o)) return null;
    const m = S(o, n);
    if (!m) throw new Error("IBC channel not found");
    const p = M(U(m, a)), u = M(this.tx.getL1Denom(a));
    return c.view({
      moduleAddress: "0x1",
      moduleName: "minitswap",
      functionName: "swap_simulation",
      typeArgs: [],
      args: [
        i.address().serialize(p).toBase64(),
        i.address().serialize(u).toBase64(),
        i.u64().serialize(e).toBase64()
      ]
    });
  }
  getIBCMessages(e) {
    const { address: s, layer: n } = this.tx.params, { denom: r, targetLayer: a } = this.sendParams, { amount: o, recipientAddress: c } = e, m = S(n, a);
    if (m)
      return [
        {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: L.fromPartial({
            sender: s,
            sourcePort: "transfer",
            sourceChannel: m,
            token: { denom: r, amount: o },
            timeoutTimestamp: B(10),
            receiver: c
          })
        }
      ];
    throw new Error("IBC channel not found");
  }
  getMessagesFromL1ToL2(e) {
    var p, u, d, l;
    const { address: s, layer: n } = this.tx.params, { denom: r, targetLayer: a } = this.sendParams, { amount: o, recipientAddress: c } = e, m = S(n, a);
    if ((p = a.metadata) != null && p.op_bridge_id && ((d = (u = a.metadata) == null ? void 0 : u.op_denoms) != null && d.includes(r)))
      return [
        {
          typeUrl: "/opinit.ophost.v1.MsgInitiateTokenDeposit",
          value: Pe.fromPartial({
            sender: s,
            bridgeId: BigInt((l = a.metadata) == null ? void 0 : l.op_bridge_id),
            to: c,
            amount: { denom: r, amount: o }
          })
        }
      ];
    if (m)
      return this.getIBCMessages(e);
    throw new Error("Not supported yet");
  }
  getMessagesFromL2ToL1(e) {
    var g, f, h;
    const { address: s, modules: n, layer: r } = this.tx.params, { denom: a, targetLayer: o } = this.sendParams, { amount: c, recipientAddress: m, minimum: p } = e, u = this.tx.getL1Denom(a), d = S(r, o), l = S(o, r);
    if ((g = r.metadata) != null && g.op_bridge_id && ((h = (f = r.metadata) == null ? void 0 : f.op_denoms) != null && h.includes(u))) {
      if (!(d && l)) throw new Error("IBC channel not found");
      const _ = M(U(l, a)), w = M(u);
      return [
        {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: L.fromPartial({
            sender: s,
            sourcePort: "transfer",
            sourceChannel: d,
            token: { denom: a, amount: c },
            timeoutTimestamp: B(10),
            receiver: `${n.swap_transfer}::swap_transfer::minit_swap_to`,
            memo: E({
              module_address: n.swap_transfer,
              module_name: "swap_transfer",
              function_name: "minit_swap_to",
              type_args: [],
              args: [
                i.address().serialize(_).toBase64(),
                i.address().serialize(w).toBase64(),
                i.u64().serialize(c).toBase64(),
                i.option(i.u64()).serialize(p).toBase64(),
                i.address().serialize(m).toBase64()
              ]
            })
          })
        }
      ];
    }
    if (d)
      return this.getIBCMessages(e);
    throw new Error("Not supported yet");
  }
  getMessagesFromL2ToL2(e) {
    var h, _, w, v, T, x, R, $;
    const { address: s, layer1: n, modules: r, layer: a } = this.tx.params, { denom: o, targetLayer: c } = this.sendParams, { amount: m, recipientAddress: p, minimum: u } = e, d = this.tx.getL1Denom(o), l = S(a, n), g = S(n, a), f = S(n, c);
    if ((h = a.metadata) != null && h.op_bridge_id && ((w = (_ = a.metadata) == null ? void 0 : _.op_denoms) != null && w.includes(d))) {
      if ((v = c.metadata) != null && v.op_bridge_id && ((x = (T = c.metadata) == null ? void 0 : T.op_denoms) != null && x.includes(d))) {
        if (!(l && g)) throw new Error("IBC channel not found");
        const V = M(U(g, o)), O = M(d);
        return [
          {
            typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
            value: L.fromPartial({
              sender: s,
              sourcePort: "transfer",
              sourceChannel: l,
              token: { denom: o, amount: m },
              timeoutTimestamp: B(10),
              receiver: `${r.swap_transfer}::swap_transfer::minit_swap_deposit`,
              memo: E({
                module_address: r.swap_transfer,
                module_name: "swap_transfer",
                function_name: "minit_swap_deposit",
                type_args: [],
                args: [
                  i.address().serialize(V).toBase64(),
                  i.address().serialize(O).toBase64(),
                  i.u64().serialize(m).toBase64(),
                  i.option(i.u64()).serialize(u).toBase64(),
                  i.u64().serialize((R = c.metadata) == null ? void 0 : R.op_bridge_id).toBase64(),
                  i.address().serialize(p).toBase64(),
                  i.vector(i.u8()).serialize([]).toBase64()
                ]
              })
            })
          }
        ];
      }
      throw new Error("Not supported yet");
    }
    if (l && f && g) {
      const [V] = new js({ ...this.tx.params, layer: n }).send({ ...this.sendParams, denom: d }).getMessages(e);
      if (V.typeUrl === "/opinit.ophost.v1.MsgInitiateTokenDeposit") {
        if (!c.metadata) throw new Error("Layer metadata not found");
        const O = {
          "@type": "/opinit.ophost.v1.MsgInitiateTokenDeposit",
          sender: $s(g, s),
          bridgeId: ($ = c.metadata) == null ? void 0 : $.op_bridge_id,
          to: p,
          amount: { denom: d, amount: m }
        };
        return [
          {
            typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
            value: L.fromPartial({
              sender: s,
              sourcePort: "transfer",
              sourceChannel: l,
              token: { denom: o, amount: m },
              timeoutTimestamp: B(10),
              receiver: "0x1::cosmos::stargate",
              memo: E({
                module_address: "0x1",
                module_name: "cosmos",
                function_name: "stargate",
                type_args: [],
                args: [i.string().serialize(JSON.stringify(O)).toBase64()]
              })
            })
          }
        ];
      }
      if (V.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer") {
        const O = M(d);
        return [
          {
            typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
            value: L.fromPartial({
              sender: s,
              sourcePort: "transfer",
              sourceChannel: l,
              token: { denom: o, amount: m },
              timeoutTimestamp: B(10),
              receiver: "0x1::cosmos::transfer",
              memo: E({
                module_address: "0x1",
                module_name: "cosmos",
                function_name: "transfer",
                type_args: [],
                args: [
                  i.string().serialize(p).toBase64(),
                  i.address().serialize(O).toBase64(),
                  i.u64().serialize(m).toBase64(),
                  i.string().serialize("transfer").toBase64(),
                  i.string().serialize(f).toBase64(),
                  i.u64().serialize(0).toBase64(),
                  i.u64().serialize(0).toBase64(),
                  i.u64().serialize(B(10)).toBase64(),
                  i.string().serialize("").toBase64()
                ]
              })
            })
          }
        ];
      }
    }
    throw new Error("Not supported yet");
  }
  getMessages(e) {
    var l, g;
    const { address: s, layer: n } = this.tx.params, { denom: r, targetLayer: a } = this.sendParams, { amount: o, recipientAddress: c } = e, m = (l = n.metadata) == null ? void 0 : l.is_l1, p = !m, u = (g = a.metadata) == null ? void 0 : g.is_l1, d = !u;
    if (n.chain_id === a.chain_id)
      return [
        {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: Te.fromPartial({
            fromAddress: s,
            toAddress: c,
            amount: [{ denom: r, amount: o }]
          })
        }
      ];
    if (m && d) return this.getMessagesFromL1ToL2(e);
    if (p && u) return this.getMessagesFromL2ToL1(e);
    if (p && d) return this.getMessagesFromL2ToL2(e);
    throw new Error("Not supported yet");
  }
}
function $s(t, e) {
  const s = "ibc-move-hook-intermediary", n = `${t}/${e}`, r = j(s), a = j(new Uint8Array([...r, ...P(n)]));
  return b.toBech32(k(a));
}
class Rs {
  constructor(e, s) {
    this.tx = e, this.sendNFTParams = s;
  }
  getMoveMessages(e) {
    const { recipientAddress: s, tokens: n } = e, { address: r } = this.tx.params;
    return n.map(({ object_addr: a }) => ({
      typeUrl: "/initia.move.v1.MsgExecute",
      value: D.fromPartial({
        sender: r,
        moduleAddress: "0x1",
        moduleName: "object",
        functionName: "transfer",
        typeArgs: ["0x1::nft::Nft"],
        args: [i.address().serialize(a).toBytes(), i.address().serialize(s).toBytes()]
      })
    }));
  }
  getWasmMessages(e) {
    const { recipientAddress: s, tokens: n } = e, { address: r } = this.tx.params;
    return n.map(({ collection_addr: a, nft: o }) => ({
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: K.fromPartial({
        sender: r,
        contract: a,
        msg: P(JSON.stringify({ transfer_nft: { recipient: s, token_id: o.token_id } })),
        funds: []
      })
    }));
  }
  getEvmMessages(e) {
    const { recipientAddress: s, tokens: n } = e, { address: r } = this.tx.params;
    return n.map(({ collection_addr: a, nft: o }) => {
      const c = new je.Contract(b.toPrefixedHex(a), Ie);
      return {
        typeUrl: "/minievm.evm.v1.MsgCall",
        value: Ce.fromPartial({
          sender: r,
          contractAddr: a,
          input: c.interface.encodeFunctionData("transferFrom", [
            r.startsWith("init1") ? b.toHex(r) : r,
            r.startsWith("init1") ? b.toHex(s) : s,
            o.token_id
          ])
        })
      };
    });
  }
  getMessagesWithinLayer(e) {
    var a, o;
    const { targetLayer: s, recipientAddress: n } = e, { layer: r } = this.tx.params;
    if (!r || !s) throw new Error("Layer not found");
    if (!n) throw new Error("Recipient address is required");
    switch ((o = (a = r.metadata) == null ? void 0 : a.minitia) == null ? void 0 : o.type) {
      case "miniwasm":
        return this.getWasmMessages(e);
      case "minievm":
        return this.getEvmMessages(e);
      default:
        return this.getMoveMessages(e);
    }
  }
  async getIBCMessages(e) {
    var d, l;
    const { targetLayer: s, recipientAddress: n, tokens: r } = e, { address: a, layer: o } = this.tx.params, { collectionAddress: c } = this.sendNFTParams, m = r.map(({ nft: { token_id: g } }) => g), p = (l = (d = o.metadata) == null ? void 0 : d.minitia) == null ? void 0 : l.type, u = W(o, s);
    if (!u) throw new Error("IBC channel not found");
    switch (p) {
      case "miniwasm":
        return r.map(({ collection_addr: g, nft: f }) => ({
          typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
          value: K.fromPartial({
            sender: a,
            contract: g,
            msg: P(
              JSON.stringify({
                send_nft: {
                  contract: u.port_id.split(".")[1],
                  token_id: f.token_id,
                  msg: z(
                    P(
                      JSON.stringify({
                        receiver: n,
                        channel_id: u.channel_id,
                        timeout: { timestamp: B(10).toString() }
                      })
                    )
                  )
                }
              })
            ),
            funds: []
          })
        }));
      case "minimove":
      case "minievm":
        return [
          {
            typeUrl: "/ibc.applications.nft_transfer.v1.MsgTransfer",
            value: se.fromPartial({
              sourcePort: u.port_id,
              sourceChannel: u.channel_id,
              classId: await this.getClassId(c, A(o), p),
              tokenIds: m,
              sender: a,
              receiver: n,
              timeoutHeight: { revisionNumber: 0n, revisionHeight: 0n },
              timeoutTimestamp: B(10)
            })
          }
        ];
      default:
        throw new Error("Not supported NFT");
    }
  }
  async getInterchainMessages(e) {
    var _, w;
    const { targetLayer: s, recipientAddress: n, tokens: r } = e, { address: a, layer1: o, layer: c } = this.tx.params, { collectionAddress: m } = this.sendNFTParams, p = (w = (_ = c.metadata) == null ? void 0 : _.minitia) == null ? void 0 : w.type, u = r.map(({ nft: { token_id: v } }) => v), d = W(c, o), l = W(o, c), g = W(o, s);
    if (!d) throw new Error("Not supported yet");
    if (!l) throw new Error("Not supported yet");
    if (!g) throw new Error("Not supported yet");
    if (!s.metadata) throw new Error("Layer metadata not found");
    const f = await this.getTargetChainCollectionAddress(
      m,
      d.port_id,
      d.channel_id,
      l.port_id,
      l.channel_id,
      A(c),
      p
    ), h = E({
      module_address: "0x1",
      module_name: "cosmos",
      function_name: "nft_transfer",
      type_args: [],
      args: [
        i.string().serialize(n).toBase64(),
        i.address().serialize(f).toBase64(),
        i.vector(i.string()).serialize(u).toBase64(),
        i.string().serialize(g.port_id).toBase64(),
        i.string().serialize(g.channel_id).toBase64(),
        i.u64().serialize(0).toBase64(),
        i.u64().serialize(0).toBase64(),
        i.u64().serialize(B(10)).toBase64(),
        i.string().serialize("").toBase64()
      ]
    });
    switch (p) {
      case "miniwasm":
        return r.map(({ collection_addr: v, nft: T }) => ({
          typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
          value: K.fromPartial({
            sender: a,
            contract: v,
            msg: P(
              JSON.stringify({
                send_nft: {
                  contract: d.port_id.split(".")[1],
                  token_id: T.token_id,
                  msg: z(
                    P(
                      JSON.stringify({
                        receiver: "0x1::cosmos::nft_transfer",
                        channel_id: d.channel_id,
                        timeout: { timestamp: B(10).toString() },
                        memo: h
                      })
                    )
                  )
                }
              })
            ),
            funds: []
          })
        }));
      case "minimove":
      case "minievm":
        return [
          {
            typeUrl: "/ibc.applications.nft_transfer.v1.MsgTransfer",
            value: se.fromPartial({
              sourcePort: d.port_id,
              sourceChannel: d.channel_id,
              classId: await this.getClassId(m, A(c), p),
              tokenIds: u,
              sender: a,
              receiver: "0x1::cosmos::nft_transfer",
              timeoutHeight: { revisionNumber: 0n, revisionHeight: 0n },
              timeoutTimestamp: B(10),
              memo: h
            })
          }
        ];
      default:
        throw new Error("Not supported NFT");
    }
  }
  async getMessages(e) {
    const { targetLayer: s, recipientAddress: n } = e, { layer: r } = this.tx.params;
    if (!r || !s) throw new Error("Layer not found");
    if (!n) throw new Error("Recipient address is required");
    const a = r.chain_id, o = s.chain_id;
    return !o || a === o ? this.getMessagesWithinLayer(e) : W(r, s) ? this.getIBCMessages(e) : await this.getInterchainMessages(e);
  }
  transformAddress(e) {
    return (e.startsWith("0x") ? e.slice(2) : e).padStart(64, "0");
  }
  async getClassId(e, s, n) {
    const r = fs(s, e, n), { creator: a, name: o } = await r.getCollectionInfo();
    switch (n) {
      case "minimove":
        return a === "0x1" && o.startsWith("ibc/") ? o : `move/${this.transformAddress(e)}`;
      case "minievm": {
        if (o.startsWith("ibc/")) {
          const c = o.slice(4);
          if (await N.get(`ibc/apps/nft_transfer/v1/class_traces/${c}`, { prefixUrl: s }).json()) return o;
        }
        return `evm/${b.toHex(e)}`;
      }
      default:
        throw new Error("Not supported NFT");
    }
  }
  async getTargetChainCollectionAddress(e, s, n, r, a, o, c) {
    switch (c) {
      case "minimove": {
        let m = await this.getClassId(e, o, c), p = `${r}/${a}`;
        if (m.startsWith("ibc/")) {
          const g = m.slice(4), { class_trace: f } = await N.get(`ibc/apps/nft_transfer/v1/class_traces/${g}`, { prefixUrl: o }).json();
          if (f.path === `${s}/${n}`) return f.base_class_id.slice(5);
          m = f.base_class_id, p = f.path.startsWith(`${s}/${n}/`) ? f.path.slice(`${s}/${n}/`.length) : `${r}/${a}/${f.path}`;
        }
        const u = `${p}/${m}`, d = j(u), l = k(d).toUpperCase();
        return ne("0x1", `ibc/${l}`);
      }
      case "miniwasm": {
        const m = s.split(".")[1], p = z(P(JSON.stringify({ class_id: { contract: e } }))), u = `cosmwasm/wasm/v1/contract/${m}/smart/${p}`;
        let d = await N.get(u, { prefixUrl: o }).json();
        const l = d.data === null ? e : d.data, g = l.startsWith(`${s}/${n}/`) ? l.slice(`${s}/${n}/`.length) : `${r}/${a}/${l}`;
        if (g.startsWith("move/"))
          return g.slice(5);
        const f = j(g), _ = `ibc/${k(f).toUpperCase()}`;
        return ne("0x1", _);
      }
      default:
        throw new Error("Not supported NFT");
    }
  }
}
function Os(t, e = ["uinit"]) {
  function s(r, a) {
    if (r !== a)
      return [...t.entries()].find(
        ([, { assets: o }]) => o.some(({ denom: c }) => c === r) && o.some(({ denom: c }) => c === a)
      );
  }
  function n(r, a) {
    if (r !== a)
      for (const o of e) {
        const c = s(r, o), m = s(a, o);
        if ((c == null ? void 0 : c[1].type) === "dex" && (m == null ? void 0 : m[1].type) === "dex")
          return { path: [r, o, a].map(M), lpTokens: [c[0], m[0]] };
      }
  }
  return function(r, a) {
    if (r === a) return { mode: "send", path: [], lpTokens: [] };
    const o = s(r, a);
    if (o)
      return {
        mode: "direct",
        type: o[1].type,
        path: [r, a].map(M),
        lpTokens: [o[0]]
      };
    const c = n(r, a);
    return c ? { mode: "route", ...c } : { mode: "unsupported", path: [], lpTokens: [] };
  };
}
class Ws {
  constructor(e, s) {
    this.tx = e, this.swapParams = s;
  }
  get resolve() {
    return Os(this.swapParams.swaplist);
  }
  getType({ offerDenom: e, askDenom: s }) {
    const { getL1Denom: n } = this.tx, { mode: r } = this.resolve(n(e), n(s));
    if (r === "direct") {
      const { type: a } = this.resolve(n(e), n(s));
      return a ?? "dex";
    }
    return "dex";
  }
  getIsSupported({ offerDenom: e, askDenom: s }) {
    const { getL1Denom: n } = this.tx, { mode: r } = this.resolve(n(e), n(s));
    return r !== "unsupported";
  }
  getIsValid({ amount: e }) {
    const { getL1Denom: s } = this.tx, { offerDenom: n, askDenom: r } = this.swapParams;
    if (!y(e).gt(0) || !(n && r)) return !1;
    const { mode: a } = this.resolve(s(n), s(r));
    return a !== "unsupported";
  }
  async fetchSwapFeeRate() {
    const { getL1Denom: e } = this.tx, { layer1: s } = this.tx.params, { offerDenom: n, askDenom: r, swaplist: a } = this.swapParams, { mode: o, lpTokens: c } = this.resolve(e(n), e(r));
    if (o !== "direct") return null;
    const [m] = c, p = a.get(m);
    if (!p) return null;
    switch (p.type) {
      case "dex": {
        const u = gs(A(s)), { swap_fee_rate: d } = await u.getConfig(m);
        return d;
      }
      case "stableswap": {
        const u = we(A(s)), { swap_fee_rate: d } = await u.getPool(m);
        return d;
      }
      default:
        return null;
    }
  }
  getDecimals(e) {
    const { getL1Denom: s } = this.tx, { swaplist: n } = this.swapParams, a = [...n.values()].map(te("assets")).flat().find((o) => o.denom === s(e));
    if (!a) throw new Error("Token not found");
    return a.decimals;
  }
  async simulate({ amount: e, type: s }) {
    if (!this.getIsValid({ amount: e })) return null;
    const { getL1Denom: n } = this.tx, { modules: r, layer1: a } = this.tx.params, { offerDenom: o, askDenom: c } = this.swapParams, m = ys(A(a), r.dex_utils), p = we(A(a)), u = async (f) => {
      const h = await f(e), [_, w] = Array.isArray(h) ? h : [h, "0"];
      if (!_) return null;
      const v = this.getDecimals(c) - this.getDecimals(o), T = y(_).div(e).times(y(10).pow(v)).toFixed(18);
      return { returnAmount: _, expectedPrice: T, priceImpact: w };
    }, { mode: d, path: l, lpTokens: g } = this.resolve(n(o), n(c));
    switch (d) {
      case "direct": {
        const f = s === "dex" ? m.getSwapSimulation(l[0], g[0]) : p.getSwapSimulation(l[0], l[1], g[0]);
        return await u(f);
      }
      case "route": {
        const f = m.getRouteSwapSimulation(l[0], g);
        return await u(f);
      }
      default:
        return null;
    }
  }
  getL1Messages(e) {
    const { amount: s, simulated: n, slippagePercent: r } = e, { getL1Denom: a } = this.tx, { modules: o, address: c } = this.tx.params, { offerDenom: m, askDenom: p } = this.swapParams, { mode: u, lpTokens: d } = this.resolve(a(m), a(p)), l = ee(n, r);
    switch (u) {
      case "direct":
        return [
          {
            typeUrl: "/initia.move.v1.MsgExecute",
            value: D.fromPartial({
              sender: c,
              moduleAddress: "0x1",
              moduleName: "dex",
              functionName: "swap_script",
              typeArgs: [],
              args: [
                i.address().serialize(d[0]).toBytes(),
                i.address().serialize(M(m)).toBytes(),
                i.u64().serialize(s).toBytes(),
                i.option(i.u64()).serialize(l).toBytes()
              ]
            })
          }
        ];
      case "route": {
        if (!o.dex_utils) throw new Error("Utility module not found");
        return [
          {
            typeUrl: "/initia.move.v1.MsgExecute",
            value: D.fromPartial({
              sender: c,
              moduleAddress: o.dex_utils,
              moduleName: "dex_utils",
              functionName: "route_swap",
              typeArgs: [],
              args: [
                i.address().serialize(M(m)).toBytes(),
                i.vector(i.address()).serialize(d).toBytes(),
                i.u64().serialize(s).toBytes(),
                i.option(i.u64()).serialize(l).toBytes()
              ]
            })
          }
        ];
      }
      default:
        throw new Error("Invalid swap mode");
    }
  }
  getL2Hook(e) {
    var _, w, v, T;
    const { amount: s, simulated: n, slippagePercent: r } = e, { getL1Denom: a } = this.tx, { modules: o, layer: c, address: m, layer1: p } = this.tx.params, { offerDenom: u, askDenom: d } = this.swapParams, { mode: l, lpTokens: g } = this.resolve(a(u), a(d)), f = ee(n, r), h = q({ layer: c, layer1: p });
    if (!h) throw new Error("IBC channels not found");
    if ((w = (_ = c.metadata) == null ? void 0 : _.op_denoms) != null && w.includes(a(u))) {
      const x = M(U(h.fromL1ToL2, u)), R = M(a(u));
      return {
        receiver: `${o.swap_transfer}::swap_transfer::mixed_route_swap_transfer`,
        memo: E({
          module_address: o.swap_transfer,
          module_name: "swap_transfer",
          function_name: "mixed_route_swap_transfer",
          type_args: [],
          args: [
            i.address().serialize(x).toBase64(),
            i.vector(i.vector(i.vector(i.u8()))).serialize([
              [i.u8().serialize(
                1
                /* MinitSwap */
              ).toBytes(), i.address().serialize(R).toBytes()],
              [i.u8().serialize(
                0
                /* Dex */
              ).toBytes(), i.address().serialize(g[0]).toBytes()]
            ]).toBase64(),
            i.u64().serialize(s).toBase64(),
            i.option(i.u64()).serialize(f).toBase64(),
            i.string().serialize(m).toBase64(),
            i.string().serialize("transfer").toBase64(),
            i.string().serialize(h.fromL1ToL2).toBase64(),
            i.string().serialize("").toBase64()
          ]
        })
      };
    }
    if ((T = (v = c.metadata) == null ? void 0 : v.op_denoms) != null && T.includes(a(d))) {
      const x = M(a(u));
      if (!c.metadata.op_bridge_id) throw new Error("op_bridge_id not found");
      return {
        receiver: `${o.swap_transfer}::swap_transfer::swap_deposit`,
        memo: E({
          module_address: o.swap_transfer,
          module_name: "swap_transfer",
          function_name: "swap_deposit",
          type_args: [],
          args: [
            i.address().serialize(g[0]).toBase64(),
            i.address().serialize(x).toBase64(),
            i.u64().serialize(s).toBase64(),
            i.option(i.u64()).serialize(f).toBase64(),
            i.u64().serialize(c.metadata.op_bridge_id).toBase64(),
            i.address().serialize(m).toBase64(),
            i.vector(i.u8()).serialize([]).toBase64()
          ]
        })
      };
    }
    if (l === "direct") {
      const x = M(a(u));
      return {
        receiver: `${o.swap_transfer}::swap_transfer::swap_transfer`,
        memo: E({
          module_address: o.swap_transfer,
          module_name: "swap_transfer",
          function_name: "swap_transfer",
          type_args: [],
          args: [
            i.address().serialize(g[0]).toBase64(),
            i.address().serialize(x).toBase64(),
            i.u64().serialize(s).toBase64(),
            i.option(i.u64()).serialize(f).toBase64(),
            i.string().serialize(m).toBase64(),
            i.string().serialize("transfer").toBase64(),
            i.string().serialize(h.fromL1ToL2).toBase64(),
            i.string().serialize("").toBase64()
          ]
        })
      };
    }
    if (l === "route") {
      const x = M(a(u));
      return {
        receiver: `${o.swap_transfer}::swap_transfer::route_swap_transfer`,
        memo: E({
          module_address: o.swap_transfer,
          module_name: "swap_transfer",
          function_name: "route_swap_transfer",
          type_args: [],
          args: [
            i.address().serialize(x).toBase64(),
            i.vector(i.address()).serialize(g).toBase64(),
            i.u64().serialize(s).toBase64(),
            i.option(i.u64()).serialize(f).toBase64(),
            i.string().serialize(m).toBase64(),
            i.string().serialize("transfer").toBase64(),
            i.string().serialize(h.fromL1ToL2).toBase64(),
            i.string().serialize("").toBase64()
          ]
        })
      };
    }
    throw new Error("Unsupported mode");
  }
  getL2Messages(e) {
    const { amount: s } = e, { layer: n, address: r, layer1: a } = this.tx.params, { offerDenom: o } = this.swapParams, c = q({ layer: n, layer1: a });
    if (!c) throw new Error("IBC channels not found");
    const { receiver: m, memo: p } = this.getL2Hook(e);
    return [
      {
        typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
        value: L.fromPartial({
          sender: r,
          sourcePort: "transfer",
          sourceChannel: c.fromL2ToL1,
          token: { denom: o, amount: s },
          timeoutTimestamp: B(10),
          receiver: m,
          memo: p
        })
      }
    ];
  }
  getStableswapMessages(e) {
    const { amount: s, simulated: n, slippagePercent: r } = e, { getL1Denom: a } = this.tx, { address: o } = this.tx.params, { offerDenom: c, askDenom: m } = this.swapParams, { lpTokens: p } = this.resolve(a(c), a(m)), u = ee(n, r);
    return [
      {
        typeUrl: "/initia.move.v1.MsgExecute",
        value: D.fromPartial({
          sender: o,
          moduleAddress: "0x1",
          moduleName: "stableswap",
          functionName: "swap_script",
          typeArgs: [],
          args: [
            i.address().serialize(p[0]).toBytes(),
            i.address().serialize(M(c)).toBytes(),
            i.address().serialize(M(m)).toBytes(),
            i.u64().serialize(s).toBytes(),
            i.option(i.u64()).serialize(u).toBytes()
          ]
        })
      }
    ];
  }
  getMessages(e) {
    var o;
    const { layer: s, address: n, layer1: r } = this.tx.params, { type: a } = e;
    if (!n) throw new Error("Address not found");
    if (a === "stableswap")
      return this.getStableswapMessages(e);
    if ((o = s.metadata) != null && o.is_l1)
      return this.getL1Messages(e);
    if (q({ layer: s, layer1: r }))
      return this.getL2Messages(e);
    throw new Error("Unsupported layer");
  }
}
class js {
  constructor(e) {
    H(this, "params");
    this.params = e;
  }
  get getL1Denom() {
    return ce(this.params);
  }
  send(e) {
    return new Fs(this, e);
  }
  sendNFT(e) {
    return new Rs(this, e);
  }
  swap(e) {
    return new Ws(this, e);
  }
}
BigInt.prototype.toJSON = function() {
  return this.toString();
};
export {
  b as Address,
  Dn as CoinSchema,
  tr as DEFAULT_SLIPPAGE,
  Fe as DEFAULT_SLIPPAGE_PERCENT,
  vs as EncodeObjectSchema,
  Y as FriendlyError,
  ae as LocalStorage,
  Fs as Send,
  Rs as SendNFT,
  Ws as Swap,
  Un as TimeoutError,
  js as Tx,
  Ln as TxBodyValueSchema,
  Ms as WalletNames,
  ye as accumulateChanges,
  i as bcs,
  Bn as calcChangesFromEvents,
  ee as calcMinimum,
  B as calcTimeoutIBC,
  Ps as camelToSnake,
  Fn as capitalize,
  ne as coinMetadata,
  Wn as convertCamelKeysToSnake,
  On as convertSnakeKeysToCamel,
  Kn as createAminoTypes,
  E as createHook,
  gs as createInitiaDexClient,
  ys as createInitiaDexUtilsClient,
  ls as createInitiaEvmClient,
  F as createInitiaMoveClient,
  fs as createInitiaNftClient,
  we as createInitiaStableswapClient,
  En as createInitiaUsernamesClient,
  zs as createRegistry,
  Vn as decode,
  es as decodeAddress,
  M as denomToMetadata,
  jn as encode,
  Es as encodeSecp256k1Pubkey,
  Gn as encodeSecp256k1Signature,
  ze as ensureValidURL,
  Ie as erc721Abi,
  he as erc721Interface,
  Ue as extractErrorInfo,
  ps as fetchAllPages,
  Zn as fetchFriendlyError,
  kn as fetchTokenInfo,
  Ne as findChannel,
  Qn as findInitialFeeDenom,
  W as findNftTransferChannel,
  S as findTransferChannelId,
  $n as formatAmount,
  bs as formatNumber,
  Rn as formatPercent,
  _s as getDecimals,
  Xn as getFeeInfo,
  Ls as getFriendlyErrorMessage,
  Ds as getGasPrice,
  U as getIBCDenom,
  q as getIbcChannels,
  ce as getL1Denom,
  xn as getL2Denom,
  ws as getLogo,
  zn as getName,
  ds as getNextPageParam,
  ke as getOpDenom,
  ms as getProxyImage,
  Nn as getRPC,
  A as getRest,
  qn as getSignAmino,
  er as getSwappableDenoms,
  ks as initiaRegistryTypes,
  hs as isUsernameValid,
  De as messages,
  Jn as parseAccount,
  cs as parseMoveAttributes,
  An as parsePaginatedResponse,
  as as primaryCoinStore,
  As as pubkeyType,
  Is as registryTypes,
  Ss as snakeToCamel,
  In as sortBalances,
  Cn as stringifyBcsArgs,
  us as stringifyMessageValue,
  Pn as summarizeAminoMessage,
  Sn as summarizeMessage,
  xs as toAmount,
  _e as toInitiaTokenInfo,
  Bs as toQuantity,
  Q as transformKeys,
  Hn as truncate,
  Yn as validateQuantityInput,
  Us as validateSlippage
};
